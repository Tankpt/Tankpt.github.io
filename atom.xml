<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Tankpt's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://tankpt.github.io/"/>
  <updated>2015-10-17T15:32:10.018Z</updated>
  <id>http://tankpt.github.io/</id>
  
  <author>
    <name><![CDATA[Tankpt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[新的起点]]></title>
    <link href="http://tankpt.github.io/2015/10/17/20151017-sum/"/>
    <id>http://tankpt.github.io/2015/10/17/20151017-sum/</id>
    <published>2015-10-17T13:38:13.000Z</published>
    <updated>2015-10-17T15:32:10.018Z</updated>
    <content type="html"><![CDATA[<p>灵感一现，写点东西</p>
<a id="more"></a>
<h2 id="关于工作">关于工作</h2><p>好久没有写博客，不过前几天刚刚顺利入职转正了，开始了一段新的历程，关于最近也确实是忙，不过自己也确实是变懒了，少了以前在学校时光里的那种折腾琢磨和执着。</p>
<p>看了日子，今天是入职以来的第96天貌似，马上就要100天了。想想真是好快，离开校园走向职场，慢慢开始做各种不同的项目，少了学校里的几分单纯和简单，多了几分生活中的压力。</p>
<p>身边的同事都挺nice的，对于我这样的同学还是会很耐心的指导我，遇到的一些后端也很nice，在这样的氛围里真的挺好的。真是公司的规模确实有点太大，有些合作起来资源配合还是很麻烦的，效率也很低，不过这也没办法。</p>
<h2 id="关于最近的项目">关于最近的项目</h2><p>手指算了算，从入职以来到现在，差不多做了有四五个+的项目，感受还是蛮多的</p>
<h3 id="一个老项目">一个老项目</h3><p>当时也只是leader随手分配的一个任务，没想到在这一段时间里，大大小小维护了三期，改版了三次，总结起来就是坑～～</p>
<p>前人的老代码，不知道多了过久了，也不知道中间是否还有人去维护过，里面混杂的好恶心的逻辑，而且最后重构完发现还有一些多余的东西，这不是明摆着加大后期人员维护的难度么</p>
<h3 id="一个作为支援方的项目">一个作为支援方的项目</h3><p>这个项目的就是感觉前期的准备不充分，一开始的时候计划的很美好，到实践起来的时候发现，各种组件不能调用，同样的一段逻辑，提供给三方跟二方的竟然需要写两套。原来的类库设计者也没考虑好，这个真是坑出翔了</p>
<p>还有就是每个人同时都在做几个并行的东西，无力顾及这个项目，感觉自己在其中也做了一会推动者的感觉，感觉虽然很累，但是还是很有成就感，感觉在项目中主动去推动他发展比被动等待资源要好的太多了，不过需要多跑跑，多问问。而且全部的开发之间需要信息的沟通及时畅通，这次就遇到了互相不知道信息的情况</p>
<h3 id="一个另类角度的项目">一个另类角度的项目</h3><p>其实用另类角度这个词也不太对，只是里面代码写法以及组织方式跟自己的风格很不一样，对于我来说是一个完全的新事物，三个人写了三个端，目测以后我要一个人来hold住，要统一三个人的代码也是蛮刺激的，学习新东西的过程总是痛苦而刺激的</p>
<p>感觉整体的设计风格，虽然还没领悟到，但是他的实现方式就是继承的方式，这个我还是觉得非常亲切的，同时也比较支持这样的方式，虽然学习的成本有点大，但是非常方便。同时也吐槽下这个项目，一开始的设计没考虑到需要给其他人看吧，0注释也是醉了</p>
<h3 id="总结">总结</h3><ol>
<li>对于恶心的代码，趁早重构！现在不改拖到后期只会让你更加恶心，小病不除，积累到大病就难了。别抱着这次的需求不涉及到就不改，因为很有可能以后还是你维护，至少自己看到了主动去重构也算是一个攒人品吧</li>
<li>关于注释，其实我后来看到老大还特意邮件里提到了，注释里需要写的不是what而是更多的why，嗯，我赞同同时也不太赞同，我觉得就是一些稍微复杂的地方需要都写上，节省以后人的维护</li>
<li>良好的css规范是非常重要的，比较好的语意化同时可以避免冲突，关于这点对于一个多人维护的大型项目是很重要的</li>
<li>主动去推动项目的发展比被动等待资源要好的太多</li>
<li>实现一个东西的方法有很多种，我们会经常习惯于自己最熟悉的东西，而不会去尝试新的，换个角度去看问题也许会很不错</li>
</ol>
<h2 id="关于计划">关于计划</h2><p>想了想一个最近阶段性的计划</p>
<ol>
<li>好好hold住这个“另类”的项目，重构代码，从中吸取三个人的精华，好好总结，重构只是其中的一步。</li>
<li>身体真的需要长期投资，好好工作，好好生活，偶尔也需要停停脚步思考下，调整下自己，多陪陪接人</li>
<li>多关注些互联网的信息，增加知识面，懂点产品用研的东西，对于长期维护的项目，可以从产品的角度去推动发展他</li>
</ol>
<p>写在最后，希望等我入职一周年的时候，可以想起来当初给自己留的话：极致，好奇心。要把手里的事情做到极致，永远保持一颗向上的好奇心，探索挖掘</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>灵感一现，写点东西</p>]]>
    
    </summary>
    
      <category term="总结" scheme="http://tankpt.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <link href="http://tankpt.github.io/2015/07/13/20150713-performance/"/>
    <id>http://tankpt.github.io/2015/07/13/20150713-performance/</id>
    <published>2015-07-13T09:40:15.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>前段时间稍微了解了一些关于性能优化的几个点，所以整理以下，基本上参考了很多的博文，这里算是对一些资源的汇总，原创的东西并不多<br><a id="more"></a></p>
<p>##一、减少http请求<br>在一个网页的下载过程中，浏览器需要一个个去下载其中的组件，而这需要发起一个个的http请求来获得，对于一个http的请求所花费的时间包括了：建立连接的时间，发送请求的时间，等待服务器响应的时间，接收数据的时间，在《高性能网站建设》一书中提到了黄金法则就指明“只有10%~20%的最终用户相应时间花在了下载HTML文档上，其他都是花在了下载页面中的所有组件上”，所以尽量减少http的请求对于网页或者是App的优化有着很大的影响。具体的可以从如下两个方面入手：</p>
<p>###1.1 前端的优化<br>（1）使用CSS Sprites技术，将一些比较小的Icon等等之类的图片合并为一张图片，最后采用CSS中的background-position属性来定位具体的图标，从而将原来需要下载多个图标的http请求最后变为一个。适用于那些小的图标以及Icon类似的图片，不适合比较大型的图片。<br>（2）合并CSS和Javascript代码，开发过程中一般由多人合作开发，代码也按照一定的功能模块进行划分编写，所以开发完成无论是CSS还是Javascript都是多个代码文件，如果不进行合并，则多个文件会多次请求并下载，所以可以通过一些工程化的工具在代码发布的前夕将所有的代码进行合并，从而达到减少请求的目的。<br>（3）对于一些图片可以使用map的方法，这样一块区域只需要一次图片的请求，或者是把一些图片通过base64的编码方式内敛在页面中，不过这种方法可能会消耗一些CPU的资源。<br>（4）对于一些ajax请求，可以使用一些ajax框架中的方法，通过跟后台的配合，将多个ajax请求合并在一起，比如使用DWR来发送请求时就可以做到这点。</p>
<p>###1.2 服务端的优化<br>Combo技术最初出现源于《高性能网站建设指南》的规则一所提到“减少HTTP请求”，是一个在服务端提供，合并多个文件请求在一个响应中的技术。在生产环境中，Combo功能有很多实现，例如Tengine、Combo Handler（Yahoo!开发的一个Apache模块）。它实现了开发人员简单方便地通过URL来合并JavaScript和CSS文件，从而大大减少文件请求数，一个在服务端提供，合并多个文件请求在一个响应中的技术。</p>
<p>##二、压缩内容<br>在对http请求优化完毕之后，我们可以做的就是将具体的一个请求看看是否可以将文件的大小进行优化，文件越大需要消耗在传输时间上面的消耗也越大，特别在移动端，对于用户的流量要十分的谨慎和小心，因为移动端的流量要比PC端的资费要贵的多。<br>（1）由于前端的HTML、CSS、Javascript语言的特性，这些代码可以进行压缩，比如换行这些的字符可以不用，通过一些工程化的工具完全可以做到这点，将上诉三者的代码量进行优化，压缩后的文件大小变化很大，可以优化一半以上。一些比较出名的压缩工具比如YUI Compressor、Google的Closure Compiler、uglifyjs等。<br>（2）压缩图片：对于一些高质量的图片一些文件都比较大，现在也有一些成熟的技术可以较大幅度的将图片的大小进行压缩，但是同时又不会对图片的质量有很大的改变，比如可以在PS中设置图片的质量，从而降低文件的大小，或者是可以通过一些第三方的工具比如Smush.it，他 是 YUI 团队制作的一款基于 YUI 的在线图片优化工具，或者采用谷歌的一个新的图片格式WebP，不过他的支持度还不是很高，所以也需要谨慎使用。<br>（3）对于服务端可以使用Gzip压缩技术。传输的内容进行gzip压缩之后可以很明显的看到文件压缩的量，大大减少减少传输时间。</p>
<p>##三、缓存<br>对于一个Web页面中包含了很多组件资源，每次加载都会需要去下载这些资源，在移动端，这无论对于性能还是加载速度或者是流量都是一个不好的情况。而现在的大部分最新的浏览器支持一些缓存的方法，可以通过一系列的方法，将页面的资源缓存浏览器中，当用户再次访问的时候，可以直接调取浏览器中已有的内容，而不用重新去服务器下载资源，其实这样也就是为了减少http的请求，从而来达到优化的目的，具体的也可以分为在服务端和在前端的方法。</p>
<p>###3.1 前端的优化<br>按照正常的方案，为了减少http的请求，可以把CSS还有Javascript全部内连载页面内部，但是这样会让首屏的页面文件变大，虽然是减少了http的请求，但是会极大的影响首屏用户的体验，所以可以将Javascript和CSS改成外联的方式进行加载。这样在实际的使用中却会有着更快的加载速度，原因是现在的浏览器中大多数都是有着缓存的功能，所以这部分的文件都会被浏览器所缓存下来，这样在下次的加载有些明显的提升，不但不会增加HTTP请求数量，而且文档的体积也会减少。此外还可以利用浏览中存储功能比如Local Storage或者是manifest离线存储等。</p>
<p>###3.2 服务端的优化<br>（1）HTTP头信息Expires（过期时间） 属性是HTTP控制缓存的基本手段，这个属性告诉缓存器：相关副本在多长时间内是新鲜的。过了这个时间，缓存器就会向源服务器发送请求，检查文档是否被修改。几乎所有的缓存服务器都支持Expires（过期时间）属性；HTTP规范中简要的称该头为“在这一日期/时间之后，响应将被认为是无效的”。例如： Expires: Thu, 15 Apr 2010 20:00:00 GMT 告诉浏览器该响应的有效性持续到2010年4月15日。因为Expires头使用一个特定的时间，它要求服务端和客户端的时钟严格同步，但实际的情况下，服务端和客户端的时间经常不同步，而且时差比较严重，所以用这个方法也不是万能的。另外，过期日期需要经常检查，一旦过期日期到了，需要在服务器中配置提供一个新的日期。这类缓存比较适合那些网站中整体的图片背景，换句话说就是那些不太容易更换的地方，可以设置一个比较合适的时间，利用好缓存。<br>（2）Cache-Control的方法：由于Expires有着一些不方便的地方，所以HTTP1.1引入了Cache-Control头来克服Exipres头的限制。Cache-Control使用max-age指令指定组件被缓存多久，它以秒为单位定义了一个更新窗，这样就可以避免因为服务端和客户端之间的时间点不一样而产生的问题。使用带有max-age的Cache-Control可以消除Expires的限制，但对于不支持HTTP1.1的应用，仍希望使用Expires头。可以同时制定这两个响应头，如果两者同时出现时，HTTP规范规定max-age指令将重写Expires头。当出现了Expires头时，直到过期时间为止一直会使用缓存的版本，浏览器不会检查任何更新，直到过了过期时间。为了确保用户能够获取组件的最新版本，需要在所有的HTML页面中修改组件的文件名。<br>（3）If-Modified-Since是标准的HTTP请求头标签，所有现代的浏览器都支持最近修改 (last-modified) 的数据检查，在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中，如果你曾经访问过某页，一天后重新访问相同的页时发现它没有变化，并奇怪第二次访问时页面加载得如此之快。<br>（4）ETag是Web服务器和浏览器用于确认缓存组件的有效性的一种机制。ETag在HTTP1.1中引入，用于检测浏览器缓存中的组件与原始服务器上的组件是否匹配。ETag是唯一标识了一个组件的一个特定版本字符串。唯一的约束是该字符串必须用引号引起来。原始服务器使用Etag响应头来指定组件的ETag。其工作方式是：服务器发送你所请求的数据的同时，发送某种数据的 hash (在 ETag 头信息中给出)。hash 的确定完全取决于服务器。当第二次请求相同的数据时，你需要在 If-None-Match: 头信息中包含 ETag hash，如果数据没有改变，服务器将返回 304 状态代码。与最近修改数据检查相同，服务器仅仅 发送 304 状态代码；第二次将不为你发送相同的数据。在第二次请求时，通过包含 ETag hash，你告诉服务器：如果 hash 仍旧匹配就没有必要重新发送相同的数据，因为你还有上一次访问过的数据。</p>
<p>##四、代码的优化</p>
<p>###4.1 HTML的优化<br>（1）为了让页面有着更好的用户体验，开发者应该尽量让首屏的显示尽可能的快，这里就需要尽量让首页的HTML页面代码尽可能的小，这里就需要涉及到评估是否将CSS或则是Javascript代码内敛到页面中，虽然确实会减少Http的请求数量，但是极大的增加页面文件的体积，可能会对首屏展示有一定的影响，具体需要开发者去平衡。同时为了更快的将首屏的内容展示出来，开发者应结构化HTML，尽量做到主要的内容先展示出来，次要的后续缓慢加载。同时拟写页面的结构的时候，尽量做到简洁，因为如果过多的DOM节点会影响页面的渲染速度，换言之以更少的代码实现同样的功能为最佳。<br>（2）在CSS写在文档的头部，这样可以让首屏可以尽快的有一定的样式；而Javascript则要尽可能的放在文档的尾部或者将其设置为异步加载，因为一般加载执行Javascript代码都会阻塞页面的加载和渲染。还有比如注意一些CSS的写法减少浏览器重绘回流等等。</p>
<p>###4.2 CSS的优化<br>（1）避免CSS表达式，之所以避免少使用CSS表达式的原因在雅虎YUI中也提到了“表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给CSS表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到10000次以上的计算量。”如此频繁的计算对性能来说肯定是一个很大的消耗。当然如果没有办法非要使用，那么也要尽可能的将其优化，CSS表达式方法在其它浏览器中不起作用，因此在跨浏览器的设计中单独针对Internet Explorer设置时会比较有用，或者对低版本中进行hack来避开。<br>（2）避免使用@import：页面中加载CSS文件的方法有两种，一种是link元素，另一种是CSS 2.1加入@import。而在外部的CSS文件中使用@import会使得页面在加载时增加额外的延迟。虽然规则允许在样式中调用@import来导入其它的CSS，但浏览器不能并行下载样式，就会导致页面增添了额外的往返耗时。比如，第一个CSS文件first.css包含了以下内容：@import url(“second.css”)。那么浏览器就必须先把first.css下载、解析和执行后，才发现及处理第二个文件second.css。当你在一个外部样式表中使用第二种方式时，浏览器无法通过并行下载的方式下载这个资源，这样就会导致其他资源的下载被阻塞。<br>（3）注意CSS选择器的性能：之所以要注意CSS选择器的性能是因为要注意浏览器匹配选择器和文档元素时所消耗的时间。这里有一种跟平时思维不同的就是有关CSS的解析顺序，平时在写CSS的时候，开发者都是习惯性的从左往右的顺序拟写CSS，但是实际上浏览器解析CSS的顺序却是相反的，是从右往左的顺序，这就会造成一个很大的区别，比如#header &gt; a {font-weight:blod;}，如果按照以前的思维方式，大家都会以为先查找到id为header的节点，再去子节点中寻找标签为a的节点，CSS这样查找的话效率还是挺高的；但是实际上却不是这样的，浏览器会去寻找所有的a节点，然后再找到父节点id为header的节点未知，这样的查找性能要比之前的差一些了。如果用#header  a {font-weight:blod;}这样的方式去查找，性能要更加差，因为先要找到所有a标签中祖先元素id为header的元素直至根节点。</p>
<p>###4.3 Javascript的优化<br>（1）做好缓存：类似缓存资源一样，最常见的就是在for循环中，需要把数据的长度存储在一个临时变量中，否则每次循环都需要去读取这个数值；类似的还有在使用jQuery中，对于一个后续可能会继续用的节点，在一次$(“<em>*”)取出后，最好将他缓存起来，因为每次支持节点的查找需要一定的代价和消耗。<br>（2）控制好经常触发事件的频率：比如有时候需要的时候会对浏览的onresize事件进行监听，如果不控制好频率，只是一味的在当外界resize的时候就触发这个动作，那么对于浏览的监听事件也有点过于损耗了，想象一下，当你调整浏览器的时候，他是每一个时间的间隔其实都触发了这个事件，特别是当那个监听事件里写了很多复杂的而且消耗资源的事件，这样貌似在低版本的一些浏览器都会卡住，解决的方法就是设置一个定时器，正常情况下延迟一定的时间执行，如果再次触发则取消之前的执行，大致的代码如下<br>var resizeEvent = null;<br>if (resizeEvent) {<br>clearTimeout(resizeEvent)<br>}<br>resizeEvent = setTimeout(function(){<br>/</em>event*/<br>}, 400);<br>（3）做好回收工作：由于Javascript语言的特性，它本身就具有垃圾回收的机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。特别在一些移动端的单页面中要特别注意垃圾回收的问题，因为不像PC端的一样一样会进场刷新，单页面经常仅仅利用ajax来更新数据，所以若不好好维护好内存的大小，很容易造成奔溃等情况出现。垃圾回收原理：找出内存中不再继续使用的变量，将其所占用的内存释放，开发人员不再关心内存的使用情况，内存的分配已经无用内存的释放完全实现了自动化管理。常见的Javascript垃圾回收分为两类：标记清除、引用计数。<br>标记清除是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间，IE，Firefox，Opera，Chrome和Safari的目前都是使用的标记清除回收策略。<br>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。<br>在具体的实践中，开发者需要注意一些垃圾的回收，常见的比如，将DOM树中的一些节点删除时要一起把绑定在他上面的一些事件也同时给删除掉，这里不仅仅是为了清除不必要的事件有时甚至会出现一个动作执行多次的动作。还有就是比如闭包中的引用以及类似setTimeout这类定时器的设置，在不需要的情况下要及时清除。</p>
<p>##五、其他优化<br>（1）对一些不必要的资源可以采用惰性加载的方法来实现，即不使用的时候不加载，这样可以较大的优化页面的加载速度，比较常见的就是对于一些图片较多的页面上，可以首先加载仅在第一屏上的图片，对于页面中的不再第一屏的页面可以采用一个默认的图片，当且仅当用户下滑到那些图片的时候，再将他们从服务器加载进来。<br>（2）在兼容性允许的情况下尽量使用CSS动画而不是Javascript动画，因为使用CSS动画不占用Javascript的主线程，在一些手机上还可以利用GPU进行硬件加速（比如CSS3中的transitions属性等），很多浏览器还可以对这些动画进行优化。<br>（3）使用CDN（Content Delivery Network内容分发网络）：其作用是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。最基本的开发者可以将自身常用的一些类库部署到CDN上，或者选择一些免费的CDN提供商来引入资源，常见的一些比如360、百度、七牛、又拍云等等。<br>（4）分多个域并行加载：在HTTP 1.1规范(section8.1.4)指明浏览器应允许每个主机名（hostname）可以支持至少两个并发连接，但是浏览器默认对同一个域下的资源同时加载的数量会有所限制，所以当一个文档中所包含的资源数要比主机的最大并发数还多的时候，浏览器则发出允许的最大并发数的请求，并将剩余的请求加入队列中。一旦有请求完成，浏览器会立即发出队列中的下一批允许的最大并发数的请求，它会一直重复这个过程直到下载完所有的资源，具体一点就是如果一个浏览器允许每个主机名可以有4个并发连接，并且一个页面可以引用同域的100个资源，那么每4个资源会占用1个往返时间，总的下载时间为25个往返时间。这个数量还跟浏览器的类型、版本、以及HTTP版本有关，根据最新的Browserscope的结果，分别如下：Chrome32、34为6个，Firefox26、27为6个，Safari7.0.1为6个，Blackberry为7个，Andriod 2.3为8个，IE 10为8个，IE11为13个。</p>
<p>但是浏览器同时还提供了另一种途径就是不同域下可以并行加载资源， 这样就可以绕开上面提到的限制问题，同样的图片如果将其放在两个域，不过虽然可以通过这个方法来达到更多资源的并行下载，但是也有两个问题，一个是所有的浏览器根据不同的种类对不同域同时下载的资源数有限制，根据最新的Browserscope的结果，分别如下：Chrome32、34为10个，Firefox26、27为17个，Safari7.0.1为17个，Blackberry为9个，Andriod 2.3为10个，IE 10为17个，IE11为17个。第二个问题是每一个域的解析需要时间，每个新的TCP的连接的建立引入额外的请求往返时间，同时还可能会造成空缓存客户的DNS查找，所以这个不同域的数量也不是越多越好，一般选取在2到5个之间，具体的可以按照不同的项目进行修改。<br>（5）DNS的预加载：当我们访问一个网站如 www.amazon.com 时，需要将这个域名先转化为对应的 IP 地址，这是一个非常耗时的过程，所以解析DNS是网站性能优化的比较重要的一部分，虽然加载时间不太长，但是很难压缩起来。特别是为了并发下载资源而使用多个CDN域名来加载资源的大型网站，更不可忽视，每加载资源之前都要先进行CDN域名的DNS解析转换。如果采用DNS预加载，常用的方法是可以在头部加上&lt; link href=”//my.domain.com” rel=”dns-prefetch” /&gt;，支持该功能的浏览器就会提前对该域名进行DNS解析并且缓存一下，而不会在需要请求资源再进行解析，从而提高整体网站的性能。<br>（6）加一些过渡动画（loading状态）：当访问一些含有众多多媒体元素的页面的时候，要是直接展现给用户一片空白的页面，这样的用户体验相当不好，一种常见的方法就是在页面加载完毕的时候，默认给一个loading状态的图片或者用CSS3来实现，等待内部的内容完全加载成功后再将这层loading状态的遮罩去掉。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前段时间稍微了解了一些关于性能优化的几个点，所以整理以下，基本上参考了很多的博文，这里算是对一些资源的汇总，原创的东西并不多<br>]]>
    
    </summary>
    
      <category term="性能" scheme="http://tankpt.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[致我将要逝去的学生时代]]></title>
    <link href="http://tankpt.github.io/2015/06/25/20150625_graduate/"/>
    <id>http://tankpt.github.io/2015/06/25/20150625_graduate/</id>
    <published>2015-06-25T14:07:39.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>心里数数离毕业的时光也没几天了。有点淡淡的忧伤，致我将要逝去的学生狗生活</p>
<a id="more"></a>
<h2 id="0-_开始">0. 开始</h2><p>前几天见老同学一起吃了个饭，不知道为啥又突然聊起了，问自己读的这个研究生怎么样的感觉，我差不多是不假思索的回答：不要太爽，嗯啊。真的是跟自己原来脑中所想的计划的所要的生活不太一样，原来理解的读研生活就是天天躲在实验室里面，跟一群小伙伴，coding，看paper发paper，打dota，但是实际上是读研的时间里面，有大部分时光都是在外面实习，辗转了两家公司，见过了很多的人，想想这两年的时光里面，我们处于半学生半工作的状态（其实是全职的实习，但是又可以比较自由的请假），所以跟一般的学生也确实不太一样，感受了很多，总结起来就是学生狗最好了，但是答辩的时候跟实验室的导师这么聊起来，他回了一句”但是就是学生经济不能独立”，我竟无法反驳。<br>后来我跟我同学又说，幸好当年考研没考上心想的那个学院(感谢当年考试那个咳嗽磕到死的同学，让我考英语烦燥成了傻逼，差一点点就弃考重来一年，意料之中的挂了单科)，调剂到了现在的这个学院，要是当时考上了也许此时此刻正在苦逼看论文，怎么说呢，各有好坏，两年的时间混到了一个文凭，但是说实话质量不高，这个也承认。还好运气好，从实习到工作一路真的很顺，感谢眷顾我的运气以及一路帮忙罩着我的同学、同事、亲人，只能送一个么么哒。anyway，顺其自然，因上努力，果上随缘。</p>
<h2 id="1-_关于过去">1. 关于过去</h2><p>昨晚习惯性的睡前刷刷手机， 看到一个同学发了个状态说：今年的毕业季，然。。并没有多少感觉。<br>想想也是，本科毕业的时候，最近几天应该是纸醉金迷吧，喝喝喝不停吃喝，人生第一次喝吐也是献给了大学毕业，唱k，貌似最后都会来一首华健小哥的《朋友》来伤感一把，要是记得没错，我当时是最后一个走的（虽然被舍长来一把回马枪，然后用我留下的刮胡啫喱在寝室重要的柯南不挂科头像上面画了一个logo 122，看完好伤感，貌似这个头像一点没用，好歹当年电路期中考试考了个52挂了一次）。<br>当时最后的几天是把同学一个个都送别，校门口，然后默默的忍不住泪点，我的泪点其实很低的，那天送峰哥哥，睡了四年的一个屋子的舍友，百年修的同船渡，千牛修的共枕眠，我猜，我跟所有舍友们应该刚好修了500年。走的时候，最后一拥，我也受不了，泪点出来了。<br>离开西安的那天，是小崔还有肖博士（哈哈~），一起送的，把我和玉佩一直送到了火车上，最后离别的时候挥了挥手，记得当时玉佩都不敢看窗外，一看泪就出来，但是我敢看，因为眼睛大，可以装一会泪。<br>嗯，我就是这么怀旧，怎么了。过去的好。我不敢忘记，坏的早已淡去，可是发现年纪越来越大，不敢忘记的也会记不起来记性跟不上了，不过相信要是有一天大家又聚在了一起，一定又是喝酒吹牛逼，各位估计好多都已成家，家里贤妻估计还有小娃娃，啊哈哈。祝过去的一直很好。</p>
<h2 id="2-_关于现在">2. 关于现在</h2><p>这几天开始忙忙碌碌的毕业收尾工作，论文的收尾，一些离校手续的办理，还有房子也还没找，东西还杂乱的堆在寝室，毕业旅行也还没开始，想想我也真是一个超级拖延晚期患者，这个病什么时候才会好。<br>现在的毕业季，竟一点没有任何感觉，也许比起以前的毕业少了一份那种离别的感觉（想想以前的舍友，八个人没有俩是在一个地方的），而如今最好的几个小伙伴，全部都是在杭州，想见了只要公交过去，便可以去他们的豪宅们坐坐，少了几分那种散步天涯的感觉。两年的时间，说句实话，班里的人认识很少，在实验室混，就认识了几个实验室的同学，班里的估计也就是几个比较活跃的认识点。很多估计名字都说不上来，好尴尬。</p>
<h2 id="3-_关于未来">3. 关于未来</h2><p>好歹时光永远是公平的一维性。逝去便不会再回来，再怎么纠结，我还是变成了老的学生狗，传说中的老狗么？曾经在老公司实习的时候，好歹在开发组里也是最年轻的一枚孩子，还可以跟视觉交互卖萌来讨价还价，还可以赢得好喝不上火的加多宝一罐，可是现在发现已经老了，很多93or更年轻的孩子都来了，真是感慨时光都去哪里了，已经卖不动了，年轻就是最大的资本，可以比你多两年的时间来尝试，真是羡慕哇。<br>考虑到我打死也不要读博，也肯定考不上，纪念我逝去的学生狗的日子，一去肯定没了。<br>希望以后的日子也能够顺利，可以同事小伙伴请务必继续罩我，我也会争取三好，好好生活，好好工作，好好学习。</p>
<p>谨此献给此刻6.25的我，期待下一个阶段不同的我</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>心里数数离毕业的时光也没几天了。有点淡淡的忧伤，致我将要逝去的学生狗生活</p>]]>
    
    </summary>
    
      <category term="感悟" scheme="http://tankpt.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[好多坑]]></title>
    <link href="http://tankpt.github.io/2015/06/09/20150609_sum/"/>
    <id>http://tankpt.github.io/2015/06/09/20150609_sum/</id>
    <published>2015-06-09T02:12:16.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>移动端走到的几个吭</p>
<a id="more"></a>
<h3 id="1-_button">1. button</h3><p>对于botton在IOS上会有一个margin。需要进行重置</p>
<h3 id="2-_滚动到底部">2. 滚动到底部</h3><p>之前做的一个插件，当滚动到底部的时候检测然后进行新的内容的加载，但是经常会出现失效的情况（之所以这样是因为考虑到性能，窗口大小的获取之获取了一次，然后缓存起来），后来看了下，同样的一个页面，窗口的大小，从页面一开始进来的大小和在本页进行刷新，所获取的窗口大小是不一致的，解决方案有两种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. &#23545;&#20110;&#33719;&#21462;&#31383;&#21475;&#22823;&#23567;&#65292;&#27599;&#27425;&#26816;&#27979;&#30340;&#26102;&#20505;&#36827;&#34892;&#19968;&#27425;&#35745;&#31639;&#65292;&#36825;&#26679;&#23601;&#19981;&#10;&#20250;&#26377;&#35745;&#31639;&#22833;&#35823;&#30340;&#24773;&#20917;&#10;2. &#31532;&#19968;&#27425;&#33719;&#21462;&#30340;&#26102;&#20505;&#35762;&#25972;&#20307;&#30340;&#20195;&#30721;&#24310;&#36831;&#22788;&#29702;,setTimeout(f,0)&#10;&#21363;&#21487;</span><br></pre></td></tr></table></figure>
<h3 id="3-ios滚动">3.ios滚动</h3><p>出现了一个比较神奇的问题，就是当用户按住屏幕进行滚动后，比如出发了加载更多的一个loading动画，然后此时用手按住屏幕，会发现动画暂停了</p>
<h3 id="4-input输入框">4.input输入框</h3><p>设置input类型为number的时候，当输入的number的类型不合法的时候，input会自动过滤为空</p>
<h3 id="5-ios宽度百分比问题">5.ios宽度百分比问题</h3><p>在5c上，具体的版本号忘记了，比较老的也，对宽度的处理有点异常，对宽度比如算出来是45.8.都会舍成45，很容易造成布局的乱</p>
<h3 id="6-scroll事件">6.scroll事件</h3><p>DOM元素中塞内容的时候会触发一次scroll。应该是节点变多之后的效果，这个也可以理解</p>
<h3 id="7-ios点击闪烁">7.ios点击闪烁</h3><p>ios上点击一个区域会出现闪烁的问题，可以对那个闪烁的元素加一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-tap-highlight-color: rgba(0,0,0,0);</span><br></pre></td></tr></table></figure></p>
<h3 id="8-input_placehold问题">8.input placehold问题</h3><p>input placehold在老的安卓机子上面。计算原来设置了text-align:right也不会居中，有一个办法使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-input-placeholder&#65371;text-aligh:right&#65373;</span><br></pre></td></tr></table></figure></p>
<p>可以，但是再旧点的版本就不行了,不过还可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-input-placeholder &#123;direction: rtl;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="9-刷新字体大小变小">9.刷新字体大小变小</h3><p>有些手机上（小米+魅族）一开始进入的时候正常，但是进行一些操作之后会出现字体的变小，貌似都是那些body下的父元素没有设置过字体大小的元素会出现，解决的办法就是强制给一个字体大小</p>
<h3 id="10-js关闭键盘">10.js关闭键盘</h3><p>对于一些场景需要用js来关闭那些唤起的键盘。可以通过document.activeElement.blur();来将键盘关闭</p>
<h3 id="11-缩放问题">11.缩放问题</h3><p>对于一些页面在meta中设置了user-scalable=no的页面，发现在oppo上meta没有用。可以继续缩放，这个奇葩问题暂无解决方案</p>
<h3 id="12-浮动的处理">12.浮动的处理</h3><p>左边是浮动，右边一个bfc的时候不需要加margin-left。在一些手机上会以浮动元素的右侧开始计算。会容易有益处，比如华为安卓</p>
<p>##总结</p>
<ol>
<li>经常做一些内嵌页面的时候，会受到客户端的影响，有时候遇到的一些奇葩问题也许不是前端的，是客户端的，找到果断报</li>
<li>感觉最近做的俩移动的页面，其实难度并不大，但是兼容的问题真是好折腾，基本上整体的时间算下来，应该是后期测试联调改bug的时间大于前期的开发时间，而且一旦涉及到一些自己引组建资源问题的时候，需要找对应的开发也比较耗费时间</li>
<li><p>移动端有时候的联调，真是不方便，虽然有各种各样的联调方式，但是总会跟客户端的浏览器有点差异，打个log也相当的蛋疼，看到一个native开发的也在debug版本中顶部加了一个log的小窗口，所以自己也做了一个雷同的，还有比较大的优化空间，先贴代码</p>
</li>
<li><p>做好工程化还是很有必要的，其实也就是grunt这类的打包，前期比较折腾比较累，但是一旦配置好之后，后期就是爽歪歪的享受，大大节省开发的时间</p>
</li>
<li>整体项目的分层结构设计还是比较考验人的，一般不太会一蹴而就的，都是需要开发了多次之后慢慢修改，然后磨合调整修改到一个比较舒服的状态，对于一些旧的代码，千万不要心软偷懒放任不管，要是一开始就放任了，第二次第三次就更加不会去处理了，最夸张的情况下，就是这个页面经历了多个人的手，最后每个人都不敢在前人的代码上进行修改，一些老旧的代码越叠越多，还是很容易出问题的，到时候排查也是一个超级累的过程</li>
<li>关于一些组件的抽取，感觉这个力度还是很难把控的，松的耦合度可以让这个组件可以有更大的普适度去黏合各种场景，但是相应的代价就是可能这个组件里面本身完成事情就不多，很多的工作需要附加在使用这个组件的场景里去完成。 而其实，作为开发者，最喜欢的就是写完一个组件之后，我在我的应用场景里面仅仅做一个最简单的调用就可以完成这个功能那是最爽的了，不过一般这样的组件相应的就会有比较强的耦合性，这个也是比较纠结的一件事情</li>
<li><p>对于在客户端遇到需要处理一些多页面链路的问题，比如A-B—C这样的链路，但是从C返回B的过程中，需要将从C一些信息带回到B，在做的时候考虑想到了三个方案</p>
<pre><code>(<span class="number">1</span>) url里加参数
(<span class="number">2</span>) postMessage
(<span class="number">3</span>) 本地存储
</code></pre><p> A. 对于url里加参数，有点恶心，不好处理A-B中url里面也有参数的问题，虽然可以通过命名不一样的参数名字来绕开，但是感觉还是太奇怪了，而且这样的链路页面会跳的时候，感觉最好使用history.back()来处理（对于A—B-C，正常的逻辑，回到B页面后点击回退到A，要是用open方式打开用户手点到回退按钮，就会回到C），这样的情况下感觉就不是很合适了<br> B. postMessage，在浏览器端还是不错的支持度，但是在移动端上，兼容性并不能得到保证，为了求稳还是没有使用<br> C. 本地存储，这是最终采用的方案，使用的过程中唯一需要注意的就是要缕清楚不同页面直接跳转过程中，何时读取存储内容的时机，以及清除存储内容的时机，而且有一个不好地方就是，本地存储会一直有，要是A-B—C这样的链路走，这是正常的流程，对于一些直接跳转到B页面的这样的异常流程需要多多注意</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>移动端走到的几个吭</p>]]>
    
    </summary>
    
      <category term="总结" scheme="http://tankpt.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写在实习满三个月]]></title>
    <link href="http://tankpt.github.io/2015/06/07/20150607_summary/"/>
    <id>http://tankpt.github.io/2015/06/07/20150607_summary/</id>
    <published>2015-06-07T14:40:41.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>最近三个月来的总结。</p>
<a id="more"></a>
<h3 id="实习三个月总结">实习三个月总结</h3><p>　　来到新公司差不多也快有三个月了，接了几个移动客户端上的项目，感觉确实是移动端的页面还是挺蛋疼的，业务上面的东西也能并不是很难，但是兼容性的问题确实好麻烦，各种奇葩的安卓手机还有IOS，以及不完备的客户端。<br>　　三个月以来想想自己貌似没啥特别多的产出，相反总感觉自己做的东西好少，不知道为啥会这样，总感觉接到的完成的项目好少，有点点以数量为主的观念了。<br>　　不过确实有一点也是真的，这三个月来做的东西，抽离出来的组件的东西比以往任何时候都多了：<br>　　1. 抽取了一个下来加载的组件,中间遇到了几个还是比较有意思的问题,控制何时切换没有更多的文案、控制好何时触发这个加载请求的时机<br>　　2. 抽取了一个日历：这个其实是参考了网上开源的一个项目，本身也很简短，我这边把其进行进一步的简化处理，然后结合业务制作了一个新的日历控件，做完了觉得好像没有一开始想象的那么困难[小马过河的一种感觉]<br>　　3. 做了一个<a href="https://github.com/Tankpt/slide" target="_blank" rel="external">slide</a>的东西，类似ppt一样可以进行切换，用了animate.css的基础库，进行了简单的配对，然后组合了差不多有30中动画的效果，后来又将css打包的功能进行了优化，做到只把用到动画内容加载进去<br>　　4. 针对后来好多页面进行发布的时候，出现了需要手动替换内容，以及手动配置打点信息，资源路径替换的问题，经常需要好久才能替换好，这个过程笔记费时间，而且可以在可见的未来遇见这个项目的东西还会继续增长，所以做了三个打包的插件，分别处理这几个问题<a href="https://github.com/Tankpt/grunt-auto-spm" target="_blank" rel="external">grunt-auto-spm</a>自动配置打点信息、<a href="https://github.com/Tankpt/grunt-combo-reverse" target="_blank" rel="external">grunt-combo-reverse</a>把那些combo形式的资源进行逆解析、<a href="https://github.com/Tankpt/grunt-urlformate" target="_blank" rel="external">grunt-urlformate</a>把页面中的相对路径转化为项目的绝对路径，并同时可以配置cnd路径，熟悉了下npm的发布以及吊砸天的正则<br>　   总结一下就是感觉踩吭踩的飞起，感觉一些客户端的提供的api差距还是相当的大，要是他们可以合力推动，这样也许会给基于他们的开发更为便利，提供一整套一样的api，不过还好有厉害的同学将他们进行了封装。还有一点就是之前遇到position:fix与虚拟键盘的问题，确实折腾了好久，后来最终都没有找到一个好的解决方案，然后绕开试用这个属性来解决。这也未尝不是一种不错的解决方案。避开绕开bug雷区</p>
<h3 id="D-Day">D-Day</h3><p>机智的我在四月多１折买了门票，然后看完感觉没啥特别大的收获，可能他们说的东西自己也没多大的学习，不过见到了好多业内的出名的人，不过还是有几个点觉得比较有意思</p>
<ol>
<li>小胖的ppt的形式不错，手写还真是有心意</li>
<li>不四大大的关于0.0.0三位版本号的解释给我一点点启发，哈哈，已经用在项目中了，还有就是他说的几个神一样的js的问题{}-[] []-{} []+{} {}+[]真是无法理解。。。</li>
</ol>
<h3 id="插件">插件</h3><p>这次也是偶然的机会，然后自己尝试了下grunt插件的开发，一开始还真是不太习惯，不过写了一个后就顺手多了，三个都发布到npm上面去了，真是好忐忑，突破了０，也尝试了一些node文件流的操作，感觉还挺有意思的。不过这次做的三个插件都是比较水的，说白了只要用正则都可以解决的问题，后面的就是简单的replace工作，正则真是好蛋疼，差不多有一半的时间折腾在了正则上面，不过貌似也学了点皮毛。以后慢慢深入</p>
<h3 id="计划">计划</h3><p>想了几个简答的计划不知道能不能完成，哈哈。画个大饼也不错</p>
<ol>
<li>position:fix与虚拟键盘问题的整理</li>
<li>angular对原来项目重写一次，顺便好好学下</li>
<li>node做一个聊天室</li>
<li>node来一个git star的东西</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近三个月来的总结。</p>]]>
    
    </summary>
    
      <category term="感悟" scheme="http://tankpt.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[去年今天]]></title>
    <link href="http://tankpt.github.io/2015/04/03/20150403_sum/"/>
    <id>http://tankpt.github.io/2015/04/03/20150403_sum/</id>
    <published>2015-04-03T14:37:37.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>关于今天<br><a id="more"></a></p>
<p>##关于今天##<br>去年的今天早上我先坐了一趟公交再一趟地铁，最后再一趟公交到达实习的公司，被hr还吭了一把，竟然忘记把我列在访客名单里面，结果在公司门口傻站了半小时，后来好多事情也证明了这个HR是相当不靠谱的。然后签了协议最后被老大领到部门去，带我的师姐带我去领电脑，开始各种配环境。</p>
<p>这是人生中第一家实习的公司，回想起来还是很怀念的。现在想想，在这家公司涨了很多的眼界，看到了很多的的东西学到了很多的东西，认识了很多人，真的很感激在那里遇到的各位。视觉姐姐、老大、后端、楠哥、测试姐姐们，真的很感谢你们。一年的时间说长不长，说短也不短，转眼就过去了，我猜以我的性格估计会记着很久吧。怀念我以前的座位，组内无节操的玩笑，公司的早餐，还有公司坑爹的班车，公司里面的游戏厅，还有做过两次就被肌肉拉伤的健身房，一起实习的小伙伴们。</p>
<p>祝大家顺利，希望下一个一年更精彩</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于今天<br>]]>
    
    </summary>
    
      <category term="感悟" scheme="http://tankpt.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于前端一些想法]]></title>
    <link href="http://tankpt.github.io/2015/04/03/20150403_summary/"/>
    <id>http://tankpt.github.io/2015/04/03/20150403_summary/</id>
    <published>2015-04-03T14:35:33.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>学前端也有一段时间了。偶尔会看看一些文章，最近来到新的公司实习，看了跟之前老公司的对比，还是有点感触的。</p>
<a id="more"></a>
<p>##1. 前后端分离##<br>感觉这个词汇貌似是从node开始火了之后，开始慢慢出现到我们眼前的，新公司的这边的前段端感觉分离的还是相当的彻底的，这边的前端开发完全可以不依赖与后端，开发的流程完全可以前端先行，对于数据的依赖程度现在已经有一些比较成熟的工具可以来替代，比如mock.js，或者grunt里面也有类似的插件，通过拦截类似jQuery的ajax的方法，通过不修改借口名字的方法，去读自己的模拟数据。这边不同于以前，可能要做的一点就是接口先行，前后端的同学需要把彼此的接口的名称还有相关的数据字段都定义好，这样到时候两边同学的联调可以基本不用修改原有的代码，比较方法。<br>关于模板，现在的公司这边模板的东西是由后端进行维护的，感觉不是很好，前端做完demo之后给后端，然后有时候后端会问，这个页面里面那些地方前端进行了修改了，要是修改的地方少，那也还好，要是多了则该起来相当不方便，前后端关于模板修改的交涉就要花费一些时间。<br>而在老公司那边，前后端没分离的那么彻底，前后端的代码都是在一个仓库里面，经常更新代码之后本地启服务会遇到服务挂掉，这样都相当影响前端的开发效率，还有一点就是每次本地起服务的时间也是需要一定的代价的，其实前端关心的不是后台服务能不能跑起来，前端只管输入url后可以看到相关的页面可以展现出来。所以这样的开发模式会需要消耗很多的事件在等待后端上，不过那边好的一点就是模板引擎freemarker是由前端进行维护的，这让前端很爽，我们只要知道后端这个control中会填哪些数据即可，从页面在后端渲染完之后都是由前端来进行控制。省去这个模板维护的代价。</p>
<p>##2. 代码的复用<br>原来公司用的一个前端框架算是内部的一个框架，应该除了公司以外其他的地方很少有人用吧，但是说实话，我觉得真的很厉害，算是一条龙的服务都有，好了回归正题，来谈谈代码的服用的一些想法。<br>理论上，代码要尽量可以做到复用性，为啥呢。其实最可以理解的就是不要重复造轮子，要把时间会在刀刃上，还有的一个好处就是要是进行组建的全局的修改只需要修改一个base的组件即可，但是要做到很好的复用性其实还是比较费时间的。你可能需要更多的时间放在这个组件的设计上，要做到一个比较好的可扩展性，特别是那些作为基础的组件尤其重要，这也非常考验写代码人的思维，既好用又可扩展性强，那真是爽了，问题是所有这些东西都是需要做一个权衡的，在可用性和扩展性，我个人感觉其实还是需要有一个权衡的，要是把一个组件设计的跟业务粘合的很紧，那么开发可能是爽歪歪了，一调用就解决问题，但是这样的组件一般可扩展性都会受到约束。<br>其实这里就是涉及到你对一个功能的拆分的粒度的细分，个人觉得还是很纠结的有时候</p>
<p>##3. 代码工程化<br>感谢node的出现，多了grunt还有gulp，让前端的很多工作都可以解放出来，只需要在搭建整个工程的开始阶段费的时间陪下各个工具还有相关的参数，当完成之后，每次跑工程只需要一个命令就可以一键到位，还有watch liveload也真是大大帮忙了。<br>还有一些工具，比如git，做的好的话可以当开发者每次push自己的代码的时候就讲这类代码发布到cnd上，只要按照一定的命名规范，还是可以相当方便的。</p>
<p>##4. 分层思想</p>
<p>工程项目一大，代码的维护量就会呈现很陡的曲线上升，特别是大的项目一般不会是仅仅一个人做的，所以同样的代码很可能今天是你写，过几天由别人来修改你的代码，这里就是涉及到了代码的注释可维护性的问题了。<br>我看了下原来的部门跟现在的部门，可能两边做的项目的性质的不同，一边是多人做一个项目，一边是基本一个人会长期维护一个项目，所以在代码的层次结构上面可以比较明显的感觉到原来的部门的规范性，一般你只要知道他们习惯，你可以很容易的找到定位到相应的代码目录还有具体的文件内容。<br>说白了就是代码还是要规范点好，别让别人来踩你的吭，至少也要让别人好找你挖的吭</p>
<p>##5. 阻止前端进步的兼容性<br>这是个头疼的问题，要是没有兼容性问题，也许世界会更加的美好，可惜就是这么多浏览器，不过比较好的事情就是微软现在貌似慢慢和中国的一些公司合作，慢慢吧一些老的XPIe淘汰。他们也准备使用新的浏览器了，虽然可能需要兼容新的浏览器了。。但是我觉得应该还是比IE好把。这也是一个福音<br>新老部门里面最大的差别应该就在这里了，这边可以尝试的东西还是超级多的，很多新的特性在原来的部门是没机会用的，这边还是提供了很多的机会来尝鲜的，这个真心不错</p>
<p>##6. css的一点想法<br>其实在前端领域里面，感觉css是一个比较蛋疼的块，不想其他程序语言一样有着正规的程序逻辑可言，很多东西完全只是一个规则，没错，就是规则，至于为什么，答案就是。规范里就是这么规定的。我竟无法反驳</p>
<p>个人觉得网易的那套nec还是相当不错的规范，模块，组件的命名规则，以及一些类似功能性的css，比如f-cb就是清除浮动，f-fl就是向左浮动<br>今天下午跟带我的师兄进行了一些讨论，讨论的结果当然是谁都没说服谁，其实这个根本就没有一个固定的答案，只是两种　解决方案各有好坏。我的一个想法就是将整个页面中的一些例如f-cb这样的css抽取出来，放到页面的节点中去，我先说下几点好处</p>
<ol>
<li>这样理论上可以做到，在整个打包完的css文件中可以只有唯一的一个float:left。最简单的就是打包完的css比较简洁嘛</li>
<li>把这些带有明显语义化的类放到标签中去，带来的好处就是一看这个class我就知道他是什么结构，其实有点语义化比较好的感觉</li>
<li>还有一点比较扯淡的就是这样的话有点可以对节点的样式进行拆分组装的感觉</li>
</ol>
<p>不好的地方：</p>
<ol>
<li>挺折腾的。师兄觉得类似那类清除浮动的直接可以写在类似less或者sass的minxin中去，直接作为函数来引，反正预处理什么的问题都是工具来做了，</li>
<li>至于css可以变小，其实说实话小不了多少，而且全部这类放在html结构中，本身页面也会变大，而且，有时候可能需要用到多个f=*的时候，一个class后面会跟一堆，书写一不方便</li>
</ol>
<h2 id="最后">最后</h2><p>无论什么东西都没有一个最好的银弹，每个解决方案都是需要最一个折中的处理，有舍有得，做好选择，而且每个人判断的方法也不一样，做出的选择还是有区别的。</p>
<p>前端是个造轮子神马最快最多的地方，东西也是井喷似的出现，所以需要调整好心态，抓住不变的来迎接万变。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学前端也有一段时间了。偶尔会看看一些文章，最近来到新的公司实习，看了跟之前老公司的对比，还是有点感触的。</p>]]>
    
    </summary>
    
      <category term="总结" scheme="http://tankpt.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[14年下半年遇到的问题总结]]></title>
    <link href="http://tankpt.github.io/2015/02/27/20150227_sum/"/>
    <id>http://tankpt.github.io/2015/02/27/20150227_sum/</id>
    <published>2015-02-27T08:37:16.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>稍微整理下一些走过的问题</p>
<a id="more"></a>
<p>###1. 关于事件的解除绑定###<br>如果业务的需求或者是切换router的时候，需要将一些事件解除原来的绑定，</p>
<pre><code><span class="keyword">var</span> eventFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{
    <span class="comment">/*Event function*/</span>
}
$(<span class="string">"#a"</span>).bind(<span class="string">"click"</span>,eventFunc);
$(<span class="string">"#a"</span>).unbind(<span class="string">"click"</span>,eventFunc);
</code></pre><p>一般的情况这样即可，但是如果要将eventFunc绑定下一个this的作用域呢,可能会直接的eventFunc.bind(this)，这样来写了，可后来测试了下没有用，其实原因就在于bind函数的问题，在MDN上给bind的解释是</p>
<pre><code><span class="function"><span class="title">bind</span><span class="params">()</span></span>方法会创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入
 <span class="function"><span class="title">bind</span><span class="params">()</span></span>方法的第一个参数作为 this,传入 <span class="function"><span class="title">bind</span><span class="params">()</span></span> 方法的第二个以及以后的参数加上绑定函数
 运行时本身的参数按照顺序作为原函数的参数来调用原函数.
</code></pre><p>大致的情况就是每次bind都是返回一个新的函数，所以类似eventFunc.bind(this)===eventFunc.bind(this)返回的是false，解决的办法可以声明一个eventFunc2 = eventFunc.bind(this)，然后每次绑定和解除绑定都使用这个</p>
<p>###2. 关于usagent的正则匹配</p>
<p>一般做一些简单的在移动端做一些usagent的检测用正则来检测，比如来监测android，会写</p>
<pre><code>var <span class="built_in">test</span>Android = /(android)/ig;
<span class="built_in">test</span>Android.test(navigator.userAgent.toLowerCase());
</code></pre><p>来进行判断,类似这样的头</p>
<pre><code><span class="string">"mozilla/5.0 (linux; android 4.2.1; en-us; nexus 4 build/jop40d) applewebkit/535.19 (khtml, like gecko) chrome/18.0.1025.166 mobile safari/535.19"</span>
</code></pre><p>当然会返回true，但是要是在运行一次testAndroid.test(navigator.userAgent.toLowerCase());结果却是<strong>false</strong></p>
<p>原因是每个正则表达式都有一个 lastIndex 属性，用于记录上一次匹配结束的位置,所以第二次匹配的时候不是从０开始，解决的办法就是testAndroid.lastIndex＝０设置下</p>
<p><strong>正则有时间必须要好好深入看看</strong></p>
<p>###3. 关于location.reload() </p>
<p>window.location.reload()，一直使用的时候，都没注意里面的参数，直到上次在FF下遇到一个类似缓存的问题了，才看了下貌似有这么一段东西</p>
<pre><code>如果该方法没有规定参数，或者参数是 <span class="literal">false</span>，它就会用 HTTP 头 <span class="keyword">If</span>-Modified-Since 来检测服务器上
的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存
中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。

如果把该方法的参数设置为 <span class="literal">true</span>，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下
载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift 健的效果是完全一样。
</code></pre><p>偶尔间看到一个好玩的<a href="http://www.phpied.com/files/location-location/location-location.html" target="_blank" rel="external">535 ways to reload </a></p>
<p>###4. 浮动元素并排放兼容问题<br>IE7 下浮动元素并排放置不设置高度会错位,这个原因还未知，但是也是通过这个方法得到了解决</p>
<p>###5. 关于IE7下的tr<br>IE7下不能设置tr的border。解决的方法及就是用td来设置</p>
<p>关于这种兼容性的问题，也真是头疼，只能遇到一个解决一个，可惜没有一个银弹，推荐的是一个网站can I use　自行google，里面有很多详细的兼容介绍</p>
<p>###6. IE下有些margin属性的问题<br>IE下有些margin-left为负数没有用（查看下IEbug里面是否有这样的案例）zoom：1触发下haslayout就好了，貌似网上找到了一个例子可以看看<a href="http://w3help.org/zh-cn/causes/RB1001" target="_blank" rel="external">RB1001</a></p>
<p>###7. float 左右布局，左右div等高<br>关于实现float 左右布局，左右div等高的方法有，很多种，具体的可以看<a href="http://blog.csdn.net/wodetiankong516/article/details/12010121" target="_blank" rel="external">博文</a></p>
<p>这个方法的原理是事先通过正内边距来使其拥有足够高的布局控件，然后通过负外边距来使得其的位置不变。通过给父元素溢出隐藏，我们可以隐藏掉事先占据的足够高的空间。由两列实际的内容高度来决定整个父元素的高度，从而实现了等高。 当一列不浮动搭配正内边距加负外边距，父元素溢出隐藏，它的高度跟还是由内在元素来决定。css的精华在于，总容器里面加：overflow:hidden; 多列容器里面加：padding-bottom:32767px; margin-bottom:-32767px;</p>
<p>###8. 关于遇到一些多选的问题<br>对于一些表单，有很多多选题的时候，有一个比较投机的处理办法，就是使用位运算来进行区分1 2 4 8　类似0001 0010 0100 1000<br>一个不错的办法</p>
<p>###9. 关于一些情况下的margin<br>如下一段代码</p>
<pre><code><span class="comment">/*css*/</span>
.container{<span class="variable">width</span>: <span class="number">700</span>px;<span class="variable">height</span>: <span class="number">500</span>px;<span class="built_in">background</span>-<span class="built_in">color</span>: <span class="built_in">red</span>;}
<span class="comment">/*html*/</span>
&lt;div class=<span class="string">"container"</span>&gt;
    &lt;div class=<span class="string">"body1"</span>&gt;<span class="number">11212</span>&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>效果如下<img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20150227_sum1.png" alt="pic1"></p>
<p>然后我们在给body加点样式</p>
<pre><code><span class="comment">/*css*/</span>
<span class="class">.body1</span><span class="rules">{<span class="rule"><span class="attribute">margin-top</span>:<span class="value"><span class="number">50px</span></span></span>;}</span>
</code></pre><p>效果如下<img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20150227_sum2.png" alt="pic2"><br>可以发现父元素设置的背景色，还是跟子元素里面的内容紧贴，虽然确实是有margin的效果，但是父元素的背景色却没有将子元素的margin的间隙填满,这个效果出现的原因是<strong>父元素的第一个子元素的上边距margin-top如果碰不到有效的border或者padding,就会不断一层一层的找自己祖先元素</strong><br>个人的理解是发生了margin的重叠，子元素的margin跟父元素的margin-top进行叠加，最后将整体的margin体现在父元素上，对于解决的方案也有几种</p>
<ol>
<li>将父元素构建一个bfc</li>
<li>给父元素加上border-top或者padding-top</li>
<li>对子元素试用padding-top</li>
</ol>
<p>顺便提到一篇文章关于<a href="http://www.hicss.net/do-not-tell-me-you-understand-margin/" target="_blank" rel="external">magin</a>的很不错</p>
<p>###10. 关于windows.open<br>之前做过一个功能，大致是这样的情况，用于点击一个按钮，然后向服务端发起请求，如果请求成功则打开一个新的页面，记得当时测试的时候，在chrome浏览器中会出现，请求成功但是没有成功打开新的窗口的功能，貌似这个打开的被浏览器拦截。后来将这个异步的请求修改为同步之后就又可以了。这个应该是跟浏览器内部的安全机制有关。<br>具体可以看看这个文章<a href="http://www.520ued.com/article/5417ef368d31c11e3b0003ff" target="_blank" rel="external">window.open为何会被浏览器拦截</a></p>
<p>###其他</p>
<ol>
<li>如果在页面做一个设备的识别然后进行调转。如果页面中 有加载图片的过程，可能会出现的是图片还没加载完毕，然后就进行链接的跳转的，这样的结果是看到的图片还没加载完毕就会被打断，然后看不到图片</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>稍微整理下一些走过的问题</p>]]>
    
    </summary>
    
      <category term="总结" scheme="http://tankpt.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于移动端(一)viewport]]></title>
    <link href="http://tankpt.github.io/2015/02/03/20150203_viewport/"/>
    <id>http://tankpt.github.io/2015/02/03/20150203_viewport/</id>
    <published>2015-02-03T12:48:07.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>近段时间做了一个web app的demo，涉及到了一些在移动端开发时遇到的东西，所以来梳理下，这里主要是关于viewport的东西，</p>
<a id="more"></a>
<p>近段时间做了一个web app的demo，涉及到了一些在移动端开发时遇到的东西，所以来梳理下，这里主要是关于viewport的东西，其实在之前实习的过程中也遇到过，现在回想起来，其实原来的一些理解还是有点问题的，首先先附上<a href="http://tankpt.github.io/2014/07/16/20140716_metaviewport/">原来的一些整理理解</a></p>
<p>##关于像素##</p>
<p>###1. css像素（CSS pixels）###<br>字面意思就是在css中使用的像素，这个也很好理解，一般的从视觉拿过来的图，都是以一个一定的宽度的psd的图，这里的像素跟视觉图里的像素个人理解是一样的，这个最终将会是web端中的实物像素</p>
<p>###2. 设备像素###<br>显示屏幕的的最小物理单位</p>
<p>###3. 缩放比###<br>之所以这些概念在pc端的web中没有很大的关系的原因是，在pc端，初始的页面下，两者的缩放比是1:1，也就是说两者是相等的概念，当然现在chrome浏览器可以按住ctrl键，实现页面的缩放，从而改变缩放比，你就会看到元素被放大或者被缩小，在这一过程中，你需要注意的一点就是<strong>有多少像素在适配屏幕</strong></p>
<p>当你放大的时候，会有更少的css像素在设备的屏幕中，图会变得更加模糊，一个css像素，也许会覆盖多个设备像素，这个效果图可以看参考引文中的一些图；反之缩小的情况</p>
<p>###4. 其他几个相关的衡量指标###</p>
<p>(1) 每英寸所拥有的像素(PPI / DPI):物理尺寸跟设备像素比，数值越高，即代表显示屏能够以越高的密度显示图像</p>
<pre><code><span class="attribute">PPI </span>=<span class="string"> 对角线上的像素数 / 对角线的英寸长度</span>
</code></pre><p>(2) 设备独立像素(dips):这个貌似不怎么好解释，可以看看<a href="http://en.wikipedia.org/wiki/Device_independent_pixel" target="_blank" rel="external">wikipedia</a></p>
<pre><code><span class="operator">a</span> physical unit <span class="operator">of</span> measurement based <span class="command"><span class="keyword">on</span> <span class="title">a</span> <span class="title">co-ordinate</span> <span class="title">system</span> <span class="title">held</span> <span class="title">by</span> <span class="title">a</span> <span class="title">computer</span></span>
<span class="operator">and</span> represents <span class="operator">an</span> abstraction <span class="operator">of</span> <span class="operator">a</span> pixel <span class="keyword">for</span> use <span class="keyword">by</span> <span class="operator">an</span> application that <span class="operator">an</span> 
underlying <span class="keyword">system</span> <span class="keyword">then</span> converts <span class="built_in">to</span> physical pixels
</code></pre><p>不同设备有不同的显示效果,这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA 推荐使用这个，不依赖像素．在wikipedia上对这个概念的解释是一组基于计算机坐标系的物理单位，它代表了一个抽象的像素用来给应用来使用，同时会由计算机系统再将其转化为具体的物理像素．它的一个典型的应用就是允许了移动设备软件进行缩放显示信息以及在不同大小屏幕上进行用户交互．这个抽象单位允许一个应用可以用像素作为一个衡量单位，同时设备的图形系统会将这个抽象的单位转化为一个适合该设备的实际像素衡量单位．（设备独立像素到物理像素，这一过程会经过系统的计算转化，比如可能是四个实际的物理像素代表一个虚拟的设备独立像素）;还有一个不错的解释是:<strong>设备独立像素，处于实际屏幕和开发的css网页之间</strong></p>
<p>(3) 设备像素比率（Device Pixel Ratio，DPR）：物理像素/设备独立像素，不同的设备有着不同的DPR，通过这个参数可以区分开retina屏幕和非retina屏幕。所有的非retina屏幕的iPhones有着一个物理宽度为320的屏幕，当设置它的meta信息为<meta name="viewport" content="width=device-width">的时候，这将会设置layout viewport为320像素，所以整个页面将会自然的充满整个屏幕。因此，它有着320的物理像素和320的DIP，所以它的DPR即为1。而对于retina屏幕的iPhones有着一个物理宽度为640，但是同时若拥有一样的meta信息，则layout viewport的宽度不变，所以最后计算出来的DPR则为2，当然还有其他数值的DPR。这个信息可以通过在浏览器中读取window.devicePixelRatio属性来获取，不过存在着一些兼容性的问题</p>
<p>##关于viewport##</p>
<p>关于viewport的由来，貌似是苹果开始的，具体可以google看看，而现在则是由所有手机都支持了，关于viewPort分为两部分，分别是layout viewport &amp;&amp; visual viewport</p>
<p>首先介绍下这两种的形象的概念，这个貌似是在<a href="http://stackoverflow.com/questions/6333927/difference-between-visual-viewport-and-layout-viewport" target="_blank" rel="external">stackOverflow</a>上有大神的回复;以下是参考链接中一个博主对他的翻译</p>
<pre><code>把<span class="keyword">layout</span> viewport想像成为一张不会变更大小或者形状的大图。现在想像你有一个小一些的框架，
你通过它来看这张大图。（译者：可以理解为「管中窥豹」）这个小框架的周围被不透明的材料所环绕，
这掩盖了你所有的视线，只留这张大图的一部分给你。你通过这个框架所能看到的大图的部分就是
visual viewport。当你保持框架（缩小）来看整个图片的时候，你可以不用管大图，或者你可以
靠近一些（放大）只看局部。你也可以改变框架的方向，但是大图（<span class="keyword">layout</span> viewport）的大小和
形状永远不会变。
</code></pre><p>###1. visual viewport<br>根据字面就是可视的viewport,按照上面说的那个比喻，这个viewport就是限制你视觉范围的那个框，这个viewport跟文档的宽度没有关系</p>
<p>对于visual viewport，它是通过window.innerWidth/Height来进行度量的。很明显当用户缩小或者放大的时候，度量的尺寸会发生变化，因为屏幕上的CSS像素会增加或者减少</p>
<p>个人的理解：我感觉这个viewport对我们影响并不大，在列出几个stackoverflow上对这个的回答</p>
<pre><code>The visual viewport is <span class="operator">the</span> part <span class="operator">of</span> <span class="operator">the</span> page that’s currently shown <span class="command"><span class="keyword">on</span>-screen. </span>
The user may scroll <span class="built_in">to</span> change <span class="operator">the</span> part <span class="operator">of</span> <span class="operator">the</span> page he sees, <span class="operator">or</span> zoom <span class="built_in">to</span> change 
<span class="operator">the</span> size <span class="operator">of</span> <span class="operator">the</span> visual viewport.
</code></pre><p>###2. layout viewport###</p>
<p>好了这个viewPort还是很重要的，可以字面来进行理解，就是布局的viewport,也就是整个document的，如果不手动设置，那么不同的设备会有不同的默认数值，比如Safari iPhone: 980px,Opera: 850px,Android WebKit: 800px,IE: 974px，可能还有其他的数值，所以一般在移动端的时候都需要对其进行设置（通过meta中的viewport来设置），好了，那么问题来了，这个数值应该设置为多少？</p>
<p>(1) 个人猜想：我的理解是layout　viewport是作为整个document的宽度来设置(其实开发者比较关注的是宽度，高度貌似不是很在意),比如你完全可以设置layout viewport的宽度是900px，然后在定义一个container为780px,再对他进行全局的居中，即可</p>
<p><strong>注意</strong>：经过实验测试，这个一开始的宽度是不能超出不同设备原来定义的layout viewport的宽度，其实可以可以超出去，只是会有一个overflow:visible的效果，可以试试在iphone5上，定义meta中width为1000px,会看到一个左右移动的类似overflow:visible的效果．也很好理解，系统默认的一个layout vireport一个宽度，然后你定义了一个后等于是在他的容器内部</p>
<p>(2) 实际情况：在meta中设置width:device-width；而且会设置一些类似initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no的属性，一般的移动设备的width都是320，当然也有不是的</p>
<p>好了，那么问题又来了，要是视觉姐姐给的图是320px的，那托托没问题的，按照里面的来就好了（就算你是把页面写死成320px的也ok），but，他们还经常给640px的，要是还是写死成640px，那么，都超出了layout　viewport的宽度了诶，至于解决方案么还是有很多的，比如你可以用100%来定位等等，其实这些都不怎么好，推荐一个方法就是使用rem,可以看看阿里无线端的一个ml库，不错</p>
<p>写在最后，其实我没有特别去整理一些公式什么的，以上都是一些对于概念的整理．从小语文学的特别烂，估计这表述也就自己看看了．不过参考文章还是不错的</p>
<p>##参考##</p>
<ol>
<li><a href="http://librajt.github.io/2013/04/03/retina-display/" target="_blank" rel="external">Retina显示原理探索</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/" target="_blank" rel="external">设备像素比devicePixelRatio简单介绍</a></li>
<li><a href="http://weizhifeng.net/viewports.html" target="_blank" rel="external">两个viewport的故事（第一部分）</a></li>
<li><a href="http://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="external">A tale of two viewports — part one</a></li>
<li><a href="http://weizhifeng.net/viewports2.html" target="_blank" rel="external">两个viewport的故事（第二部分）</a></li>
<li><a href="http://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="external">A tale of two viewports — part two</a></li>
<li><a href="http://weizhifeng.net/a-pixel-is-not.html" target="_blank" rel="external">不是像素的像素不是像素</a></li>
<li><a href="https://github.com/yeol/blog/blob/master/Designer&#39;s_guide_to_DPI.md" target="_blank" rel="external">DESIGNER’S GUIDE TO DPI</a>说的挺详细的，赞</li>
<li><a href="http://www.html5dw.com/story-of-two-viewport-part-ii/" target="_blank" rel="external">两个viewport的故事(二)</a> 感觉这个版本说的不错．貌似比３好</li>
<li><a href="http://blog.csdn.net/zhchaoo/article/details/8851394" target="_blank" rel="external">csdn 上一个博主关于viewport的整理</a>　分了四篇，前两篇同上，后面两篇不错，可以看看，第四篇貌似加了浏览器底层的原理来介绍；第三篇介绍的是关于position:fix的问题</li>
<li><a href="http://www.w3cplus.com/css/A-pixel-is-not-a-pixel-is-not-a-pixel.html" target="_blank" rel="external">此像素非彼像素</a>其实跟文章5一样，只不过这里还有译者的一些理解</li>
<li><a href="http://stackoverflow.com/questions/6333927/difference-between-visual-viewport-and-layout-viewport" target="_blank" rel="external">关于两个viewport的答案</a></li>
<li><a href="https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html" target="_blank" rel="external">Viewport</a>在苹果官方文档上有关viewport的介绍</li>
<li><a href="https://developers.google.com/speed/docs/insights/ConfigureViewport" target="_blank" rel="external">google 对viewport的介绍</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>近段时间做了一个web app的demo，涉及到了一些在移动端开发时遇到的东西，所以来梳理下，这里主要是关于viewport的东西，</p>]]>
    
    </summary>
    
      <category term="mobile" scheme="http://tankpt.github.io/tags/mobile/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014总结]]></title>
    <link href="http://tankpt.github.io/2015/01/03/20150103_sum/"/>
    <id>http://tankpt.github.io/2015/01/03/20150103_sum/</id>
    <published>2015-01-03T11:47:49.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>貌似本来想着跨年晚上就写这个总结的，但是拖延症又犯了，然后就拖来拖去，拖到了今天</p>
<a id="more"></a>
<p>##关于元旦##<br>元旦本来计划要回一趟母校．后来也慢慢被搁置了，没有去成，试试年前去一次．元旦三天的假期，头一天宅着睡觉看动漫，第二天陪姐姐去置办家具，晚上一起看了个电影，感觉一般，不过也有些两点，把一部抗战的电影能拍成这样，也真是不容易，确实徐克有才，第三天起来便一天置身去爬宝石山，说实话来这边半年多了，都还没去这边爬山过，而且就是在学校的门口</p>
<p>爬山的过程中还挺有意思的，感觉可以作为一个计划，没两个月或者一个月去爬爬山，感觉跟跑步是完全两个感觉，起初还是体力有点不适应，不过后来也慢慢变好了，爬山的过程中遇到几个挺有意思的事情</p>
<ol>
<li>在黄龙洞那边过去的路上，远远的听到一个老奶奶在唱歌，唱的都是一些感觉宋主英那类的歌曲，真是难得，一开始听声音，以为是个40左右的大妈，后来边上一个老爷爷搭讪了下，说这个大妈都80了，真是厉害，不容易，有这样的心态，常保年轻态</li>
<li>第二个是爬到一个山顶的时候，看到一个大爷貌似类似在瑜伽一样，坐在瑜伽垫上面，但是听着佛教的音乐，然后感觉是在练拈花神功，哈哈，好有意思，周围很多人在围观，但是他依然可以沉醉在自己的神功中，难得</li>
<li>第三个是在下山的时候，看到了一个小伙子，看样子应该跟我相仿，在爆爆米花，就是那种小时候才能看到的那种机器，出锅的时候，还跟周围的吆喝到：＇出锅咯，要捂耳朵了＇，哈哈，一开始还没反应过来，后来才明白，然后捂住耳朵，崩的一声，爆米花，我过去买了一袋，为的一种情怀还有小时的记忆，我过去说，这个东西现在很少见咯，他说是呀，笑的很甜很干净，恩，就是跟小孩子脸上那种笑容一样，那一刻真是有点淡淡的触动，感觉应该一天的生意也不错，也许他真的是在做着自己喜欢做的事情，不为任何东西，祝小伙子以后更好</li>
<li>中间还见到几个小盆友，哈哈，好可爱，特别是小女孩＝＝！真是我的萌点，遇到一个母女，小女孩很可爱，妈妈跟爸爸电话的时候，小娃娃转头过去说，快给我说，然后就跟爸爸说：＇爸爸，晚上带我去看电影好不好＇；真是心都化掉了</li>
</ol>
<p>##关于工作##<br>咳咳，貌似最近的一些思考还有总结都会涉及到这个，也许真的是已经接触了工作了，所有经常会有一些想法，好歹这个时候工作的事情也确定了，恩，最后的决定是没留在实习的那边，说实话呢，我真的是纠结了很久很久，大概从拿到俩offer开始就纠结了，最后的决定也是差不多在一两天内决定的，差不多跟原计划反了一番，我也自己吓了一跳，不过决定之后人真的一下子很释然，很安静很平静，恩，我应该选了一个有挑战性的方向，剩下的就需要我自己充电加油，补上空缺的东西</p>
<p>前几天看到一句话，说的是人做事情，就跟跑步一样，貌似慢跑比跑跑停停要好的多，恩，想了下，最近这个渣状态也需要改改了，学习还是需要长时间的积累，貌似不是有一个3w小时的定律么？恩，每天需要拿出一个半小时的时间去学习，一小时专业的东西，半小时需要去接触一些专业外的，比如人文等等的东西，感觉理性思维还是需要跟感性的思维进行一个平衡，阴阳调和下，加油，看看能坚持多久</p>
<p>##关于这一年##<br>2014年怎么说呢，对我还是很重要的，这一年实现了从学生慢慢向工作转型的过程，感觉真的很不容易，第一次体会到了工作的压力，工作的疲惫，工作的责任，工作的协调，工友的相处，我发现我在人际方面还真的很欠缺（情商拙计）</p>
<p>有一天我突然想到，曾经13年考研失败的时候，我是多少不服调剂，心理是有多少的不甘心，当时去了那边真是心理多少的不平衡，差那么一点点就可以去一个更高的平台，恩，当时我真的是特别的不甘心，可现在回过头去想想，现在貌似混的也凑合，也许当时走那条路，我可能还没现在这么好，不是么？　不一定，哈哈，总的说来呢，条条大陆同罗马，走在自己的路上，就好好思考好好总结，走好自己的路，选择什么路并不重要，也不关键，重要厉害的是把每一条路都是走到成功的点，这样的人才不容易．</p>
<p>话说回来，平台这个东西的力量真是不容小觑，还有机缘，我真是算是见识到了，一个人要想把事做好，做成功，除了自己要努力，还有就是需要有机缘，人，还有平台的力量．</p>
<p>这一年我走的真的很顺说实话，真的没怎么遇到过挫折磨难，相比身边的几个同学，我貌似应该是最幸运的，实习中遇到的那些问题其实都不算是问题了，从找实习还有工作真是顺，不知道应该感谢谁，感谢周围的小伙伴，同学，还有导师，人超级好，教了很多道理，还有好多福利，嘿嘿，没有导师引的好头，后面估计也不会那么顺，真心感激，记得开题那天他说了一句话，工作么，开心最重要了，恩，很对；还有就是家人＆＆实习过程中的小盆友，谢谢你们，我才会这么幸运（关于实习的那部分，下次会特别写一篇，因为这占据了这大半年所有的时光，了了几子真是表达不清）</p>
<p>##关于检讨##</p>
<p>喂．说好的计划呢，都被丢哪里去了？为何这么得瑟，这么嚣张，渣渣还这么不肯努力，本来已经掉了别人几条街了，怎么还想再落后？既渣又懒，前途未卜</p>
<p>恩，毕设没做，恩，之前计划的聊天室也没做，之前信誓旦旦买了几本技术书，貌似就压在书架那边，一页没看，还经常玩手机，订阅的杂志呢？要不是元旦用一个下午那全部看完，都积累了一周没看了，哦，貌似订阅的邮件有７１封了，恩，还是说出来让自己自卑下好了</p>
<p>以前那种拼认真的劲需要赶紧照回来，继续</p>
<p>2015.1.3于西溪田家炳书院<br>by tankpt</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>貌似本来想着跨年晚上就写这个总结的，但是拖延症又犯了，然后就拖来拖去，拖到了今天</p>]]>
    
    </summary>
    
      <category term="感悟" scheme="http://tankpt.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于最近的一些想法]]></title>
    <link href="http://tankpt.github.io/2014/11/23/20141123_sum/"/>
    <id>http://tankpt.github.io/2014/11/23/20141123_sum/</id>
    <published>2014-11-23T04:28:18.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>11月的一些感受</p>
<a id="more"></a>
<p>　　慵懒的周末，自然醒后去图书馆，看了会淘宝准备换个钢笔的吸墨器，然后给自己列了个表，最近貌似开始在催着交三方了，人也到了不得不做选择的时候了，感觉之前真是超级懒and太会逃避没有执行力，这也是病</p>
<p>##关于人心##<br>　　坐下来好好想了想，可能确实是第一份工作把，感觉不好抉择，也许给其他一些同学，他们反而会很知足，恩，其实刚毕业的时候，我觉得作为一个刚毕业的学生，既没工作经验也没资历，又何德何能给自己定一个很好的身价呢？当时我觉得毕业的时候，差不多月薪给我8K，我都会很满足了，不过受到之后遇到的一些同学的影响，慢慢开始＂贪婪＂了，不再满足于这个<br>　　恩，这就是人心把，永远不会有一个终点，当你小时候的时候，会觉得能买一辆赛车就是一种很幸福奢侈的事，长大一会估计是买一辆山地越野的自行车，再长大估计又是豪车．．．无止无尽<br>　　其实自己深知自己能力达到什么水平，能遇到这样的公司，都是运气好，毕竟才学一年的时间，又能达到什么水平呢，东西的积累远远还没达到那个量的积累</p>
<p>##关于纠结##<br>　　我一直都有一种选择恐惧症，当时毕业选择考研保研的时候，真是纠结，纠结的那个时间段里面，问了很多的人，看了很多的东西，折腾了半天，以至于那段时间里看书的效率很低，白天会纠结，晚上会纠结．最后还是自己做的选择咯，很多事情，别人只能给你一个参考，但是最后的选择都是自己要做的，毕竟这条路以后都是你一个人走完的．<br>　　前几天看到kindle中推送了一个文章，说的是我这类的纠结综合征，其实呢人之所以会纠结，因为这俩选择都差不多，应该都不错，就像天平两边的东西一样，你考虑到一个问题的时候一边重，考虑到另一个东西的时候另一边又重，文中甚至说了，对于这样的选择随便选一个都可以，因为他们都不会差，做好选择之后以后就是要靠你自己去坚持走下去，有点夸张其实，不过也差不多，自己好好考虑下就做个选择<br>　　昨天跟一个同学也谈到这个问题，他说了一句话感觉挺有道理的，就是遇到这样的选择，无论你选择哪个，最后你都会遗憾的，特别是在你走在你选择的道路上遇到挫折不顺的时候，抑或是看到别人走在你选择的那条道路上很顺利的时候，这些都是需要心态的问题了<br>　　想起来以前给自己写的话：<strong>自己选择的路，就算跪也要把它跪完</strong>，当时选择考研路上遇到不顺的时候就看看这句话，会好点，不停勉励自己</p>
<p>##关于工作##<br>　　上午坐在图书馆里，一开始是想给自己列一个表格，对不同的需求点进行打分，最后计算一个加权的数值进行评估来进行选择，其实我猜测到时候就算选择出来也不会特别干扰我的选择，按照自己的想法我给列了几点自己决定在工作上的一些评估点</p>
<pre><code><span class="number">1.</span> 薪资
<span class="number">2.</span> 工作环境，同事氛围
<span class="number">3</span>．技术氛围
<span class="number">4</span>．加班程度，生活
<span class="number">5</span>．leader
<span class="number">6</span>．产品的前景
<span class="number">7</span>．成长空间
<span class="number">8</span>．公司的平台
</code></pre><p>　　我也没按照重要性来排序，只是按照自己想出来的顺序依次排列了，不同的人对以上的几点有不同的排序，都是很直接的关系到自己的工作的，比如8,7等等这些，我以前对于工作的态度就是找一份工作一直干到退休，后来在同学的指导下慢慢改观了，这个互联网的行业里面这样的做法不太现实，一般都是干几年需要跳槽，也许把，不知道以后我会怎么样<br>　　还有一点也是最近看到的文章对我的影响很大的，就是关于工作和生活，我是一个比较偏激的人，感觉会很容易变成工作狂那类的人，所以以前根本不在意加班这种事情，但是后来看到一个文章介绍了下，<strong>人之所以工作是为了什么呢</strong>，很少部分的人是为了爱好把，更多的人是为了更好的生活，所以，如果以牺牲生活来工作，这样是不是又有点矛盾了，恩，以上都是不同人会有不同的选择<br>　　其实想了想，自己之所以会那么纠结是感觉身边的同学都是选择了另一条路，感觉那条路走的会很好，很光明，而就我选择这条路，总觉得自己比别人要低人一等的那种感觉，我内心又有那么一点点的不甘服输</p>
<p>##关于计划##</p>
<p>　　现在的执行力感觉不是０了，是负数了，一找完工作，感觉整个人都颓下去了，手里的能力也慢慢块退化了，前段时间有压力的时候，还是会不停的在回来的时间里动手折腾东西，而现在github上面．我看了下貌似有一个月没提交的空白了，哎，人的惰性，貌似有个科学原理解释到，所有的物质都是向着懒散的状态靠近的，果然确实是这样，人就跟机器一样，一段时间不动，估计要钝，刀会变钝<br>　　感觉之前给自己定了很多的计划，但是都只是计划，都没有付诸实施，然后就没有然后了，时间都是这样耗过去的，一小时一天一周一年～～，好好利用碎片时间吧</p>
<p>给下周列一个计划希望可以做完</p>
<ol>
<li>聊天工具</li>
<li>研究HTML5中的媒体部分内容</li>
<li>完成一个总结</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>11月的一些感受</p>]]>
    
    </summary>
    
      <category term="感悟" scheme="http://tankpt.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js整理一:原型的理解]]></title>
    <link href="http://tankpt.github.io/2014/11/10/20140124_proto/"/>
    <id>http://tankpt.github.io/2014/11/10/20140124_proto/</id>
    <published>2014-11-10T15:54:06.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>自己对js中原型的理解整理</p>
<a id="more"></a>
<p>先介绍下几个属性，都是自己看着书上然后对这个概念的个人理解，如果有不对的地方，还请指出交流下~~，具体的参考见文章最下面
　</p>
<p>##1.1每个对象中的proto介绍##</p>
<p>关于在函数的创建过程中，每一个实体都是一个对象，而每一个对象都有一个属性proto，有些浏览器不可以查看他，不过测试了下IE11下是可以查看的，不过可以用另外的方法来替代他，比如isPrototypeOf()的方法来确定对象之间是否存在某种关系，如果a的proto指向b，那么b.isPrototypeOf(a)将会返回true的结果。<br>在加一点个人对proto的一点理解，这个属性是原型链的关键，所有之后要做的原型链的属性的搜索正式靠这个指针不停往上搜索的。</p>
<p>##1.2每个函数中的prototype属性##</p>
<p>在js中函数也是一个对象，所有他也有前面所提到的<strong>proto</strong>属性，然后他还有他自己的一个特有的属性，就是prototype属性，这个属性跟<strong>proto</strong>一样可以理解为一个指针的形式，prototype指向了函数的函数原型对象，说了这么多，来一个具体的例子试试</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fTest</span>(<span class="params">name</span>)</span>{
    <span class="keyword">this</span>.name = name;
}
fTest.prototype.getname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
};
<span class="keyword">var</span> oTest = <span class="keyword">new</span> fTest(<span class="string">"hello"</span>);
</code></pre><p><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140124_proto1.png" alt="pic1"><br>图中还写了俩个新的对象，一个是function.prototype，Object.prototype<br>　　（1）function.prototype：按照前面提到的<strong>proto</strong>的理解，既然fTest是一个函数，那么他应有有函数所有的方法，所有它的<strong>proto</strong>当然是指向了function.prototype，这里面有函数的一些基本的方法；同理对于fTest.prototype属性，他是一个Object对象，所以他也有一些对象的基本的方法，所以fTest.prototype指向的是Object.prototype；然后对于function.prototype他也是一个对象所以同上也指向了Object.prototype。然后关于一个新的指针constructor，这个在后面再提到。<br>　　（2） 当然Object.prototype已经是顶点了，他的<strong>proto</strong>就是NULL了。
　　</p>
<p>##1.3理解下组合使用构造函数和原型模式##<br>在上面的代码中function fTest中声明了一个变量name这个变量可以理解为是一个针对一个实例声明的变量，而在fTest.prototype中声明的getname方法是一个公用的方法，再看下面的代码</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fTest</span>(<span class="params">name</span>)</span>{
    <span class="keyword">this</span>.name = name;
}
fTest.prototype.getname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
};
<span class="keyword">var</span> oTest1 = <span class="keyword">new</span> fTest(<span class="string">"hello"</span>);
<span class="keyword">var</span> oTest2 = <span class="keyword">new</span> fTest(<span class="string">"hi"</span>);
<span class="comment">//oTest1.getname === oTest2.getname true</span>
<span class="comment">//oTest1.name === oTest2.name false</span>
</code></pre><p>可以理解为getname方法是共有的，而属性name是私有的，这个的话个人的理解是由于原型链的存在，当你使用oTest1.name的时候，他首先会在实例oTest1中去寻找name这个属性，如果找到了就停止，否则会继续沿着原型链向上寻找，比如getname这个方法，他不再实例中，所以要向上搜寻一次，然后便找到了这个方法，但是他是在两个实例所共享的一个fTest.prototype中的一个方法，所以他们的getname方法其实指向的是同一个方法，可以oTest1.getname === oTest2.getname测试下，返回为true。</p>
<p>##1.4原型链的实现##</p>
<p>在原型链的实现上，1.3中已经提到过一些了，现在稍微整理一下，（参考了javascript高级程序设计中的一些话），每当代码读取某一个对象的属性的时候，都会执行一次搜索，目标是具有给定名字的属性，首先在实例本身开始，如果实例中存在，则返回属性的值，否则继续搜索他指针指向的原型对象。<br>　　当然如果在原来的基础上，如果实例添加了一个属性，而这个属性在原型中也有，此时他会覆盖在原型中的那个原来的属性，再看下面的代码，很多是看js高级程序设计上面的内容的</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fTest</span>(<span class="params">name</span>)</span>{}
fTest.prototype.name = <span class="string">"hello"</span>;
fTest.prototype.getname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
};
<span class="keyword">var</span> oTest1 = <span class="keyword">new</span> fTest();
<span class="keyword">var</span> oTest2 = <span class="keyword">new</span> fTest();
oTest1.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//false</span>
oTest2.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//false</span>
oTest1.__proto__ === oTest2.__proto__;<span class="comment">//true</span>
<span class="built_in">console</span>.log(oTest1.getname());<span class="comment">//hello</span>
<span class="built_in">console</span>.log(oTest2.getname());<span class="comment">//hello</span>
<span class="comment">//下面开始变化了</span>
oTest1.name = <span class="string">"hi"</span>;
<span class="built_in">console</span>.log(oTest1.getname());<span class="comment">//hi</span>
<span class="built_in">console</span>.log(oTest2.getname());<span class="comment">//hello</span>
oTest1.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//true</span>
oTest2.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//false</span>
<span class="keyword">delete</span> oTest1.name;<span class="comment">//删除实例中的name属性</span>
<span class="built_in">console</span>.log(oTest1.getname());<span class="comment">//hello</span>
<span class="built_in">console</span>.log(oTest2.getname());<span class="comment">//hello</span>
oTest1.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//false</span>
oTest2.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//false</span>
</code></pre><p>此时将这个状态定义为State1好了，这个时候的图如下所示：<br><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140124_proto2.png" alt="pic2"><br>对上诉代码大概的进行解释以下，前几步都是跟之前一样的风格跟理解，此时oTest1. <strong>proto</strong>和oTest2. <strong>proto</strong>都指向fTest.prototype，所以他们公用一个name属性，然后这里用了hasOwnProperty方法来测试，在实例oTest1中是否有name的属性，结果是没有。oTest2同理。<br>然后下一个状态定义为State2<br><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140124_proto3.png" alt="pic3"><br>然后再执行oTest1.name = “hi”;这个话使得在实例oTest1中添加了name属性，这一点可以通过oTest1.hasOwnProperty(“name”);来证明，测试结果返回的是true，根据前面提到js查找一个变量的方法，现在他先找到了实例中的name属性，所以console.log(oTest1.getname());结果是hi，而console.log(oTest2.getname());任然为hello，因为在实例oTest2中并没有属性name，所以在原型链的查找过程中很自然的找到的是在fTest.prototype中的name属性。</p>
<p>最后又执行了delete oTest1.name;删除实例中的name属性，是这些都回复到了状态1中~~</p>
<p>最后送上一个牛逼的图，作者貌似就是图最上面的那行<br><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140124_proto4.jpg" alt="pic4"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自己对js中原型的理解整理</p>]]>
    
    </summary>
    
      <category term="js" scheme="http://tankpt.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js整理四:闭包[转载多]]]></title>
    <link href="http://tankpt.github.io/2014/11/10/20140210_block/"/>
    <id>http://tankpt.github.io/2014/11/10/20140210_block/</id>
    <published>2014-11-09T16:23:37.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>闭包</p>
<a id="more"></a>
<p>很多是参考了一篇文章==可不幸忘记源地址了。对不住源作者了，如果看到请高手我，我好修正，谢谢</p>
<p>##4.1关于js中的作用域链##<br>在博客上看到的理解：<br>(1)首先是JavaScript引擎可以访问的一个内部的属性<a href="仅供js引擎访问">[scope]</a>，里面保存的是函数被创建的时作用域中对象的集合，也被称为函数的作用域链，它决定了那些数据可以被函数访问。</p>
<p>(2)然后再来介绍下，一个函数创建的过程。当一个函数被创建后，它的作用域链会被创建该函数的作用域中可以访问的数据对象填充，例如</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2)</span>{</span>
    var <span class="built_in">sum</span>= num1 + num2;
    <span class="keyword">return</span> <span class="built_in">sum</span>;
}
</code></pre><p>在函数add创建的时候，他的作用域链中会填入一个全局的对象，包含了所有的全局的变量</p>
<p><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140210_block1.jpg" alt="pic1"></p>
<p>(3)    接着当该函数在被执行的时候<br>var total= add(5,10);<br>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。<br>这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示：<br><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140210_block2.jpg" alt="pic2"></p>
<p>在函数执行过程中，没遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。</p>
<p>//JS高级<br>当调用函数的时候，会被函数创建一个执行环境，然后通过赋值函数的内部属性[[scope]]]中的对象构建起的执行环境的作用域链。</p>
<p>(4)关于函数内部嵌套的问题<br>如果在一个函数A内部再定义了一个函数B，那么在函数B的作用域链中会将函数A（外部函数）的活动对象添加到B的作用域链中去，</p>
<p>##4.2关于闭包##</p>
<p>在阮一峰的博客中提到了闭包的两个用途，分别如下：<br>(1)可以读取函数内部的变量；<br>(2)让这些变量的值始终保持在内存中<br>注（貌似在其他的博客上看到过闭包的另外一个用途就是当你要声明一个私有变量的时候，你可以利用闭包的特性使外部对象不能访问这个变量，就是类似private的感觉）</p>
<p>闭包的注意点：<br>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<p>//—————————分割线———————————–<br>个人对闭包的理解：先看一小段代码</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>)</span>{
    <span class="keyword">var</span> i = <span class="number">0</span> ;
    <span class="keyword">var</span> B =<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{
        <span class="built_in">console</span>.log(i);
    }
    <span class="keyword">return</span> B;
}
</code></pre><p>很简短的一段，我理解的闭包就是上诉代码中，在一个函数中返回了内部定义的一个函数，这样的作用是什么呢?正常的情况下，一个函数结束后，他内部定义的变量什么的会被回收掉，但是有了这个闭包的东西就会出现例外，用到前面讲到的那个作用域链的理论来解释下，B的scope chain中有着函数A的活动对象，正是由于这点，函数B可以使用读取变量i的数值，现在这种情况下，当函数阶数后，返回了函数B，那么B就被引用着，所以他不会被回收这点毫无疑问，然后看A，A活动对象中的i变量现在被B引用着，所以他的活动对象会留着没被回收，以上都是个人的一点理解不知道对不对，若有不对的地方，希望能指出~</p>
<p>##4.3闭包与变量##<br>在js高级程序设计中提到了有关这个的问题<br>(1)问题的引出:代码如下</p>
<pre><code>function createFunctions(){
    <span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();
    <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++){
        <span class="literal">result</span>[i] = function(){
            <span class="keyword">return</span> i;
        }
    }
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>原本预期应该觉得输出的是0到9之间的数字保存在result之中，但是实际上，里面保存的值都是10；理解的方式就是每个函数的作用域链中都保存着createFunctions函数的活动对象，所以他们引用的是同一个i对象</p>
<p>注（可以这么理解，想象一下一共有十个函数在createFunctions里声明着，名字分别可以是result[0]等等的，然后在他们的scope链中都有这么一个指针指向他们的上级函数就是createFunctions的活动对象，里面有变量i，他们是指向同一个活动对象的，所以他们共享着这个i）<br>//——————分割线—————————————–<br>不过有方法可以强制改变这种情况，具体如下</p>
<pre><code>function createFunctions(){
    <span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();
    <span class="keyword">for</span>(<span class="keyword">var</span> i ;i&lt;<span class="number">10</span> ;i++){
        <span class="literal">result</span>[i] = function(num){
            <span class="keyword">return</span> function(){
                <span class="keyword">return</span> num;
            };
        }(i);
    }
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>现在这种情况呢，就不会出现内部的函数还一直占有函数createFunctions活动对象的情况了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>闭包</p>]]>
    
    </summary>
    
      <category term="js" scheme="http://tankpt.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js整理三:关于继承的方法]]></title>
    <link href="http://tankpt.github.io/2014/11/10/20140210_extend/"/>
    <id>http://tankpt.github.io/2014/11/10/20140210_extend/</id>
    <published>2014-11-09T16:15:57.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>写一些看到的继承的方法</p>
<a id="more"></a>
<p>##3.1简单的继承##</p>
<p>这个是参考了javascript高级程序设计一书上的继承方法，上一段代码如下</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>{
    <span class="keyword">this</span>.name =<span class="string">"person"</span>;
}
SuperType.prototype.getname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
};
<span class="function"><span class="keyword">function</span> <span class="title">Subtype</span>(<span class="params"></span>)</span>{
       <span class="keyword">this</span>.name = <span class="string">"man"</span>;
}
Subtype.prototype = <span class="keyword">new</span> SuperType();
<span class="keyword">var</span> instance1 = <span class="keyword">new</span> Subtype();
</code></pre><p>然后再上一个图<br><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140210_extend1.jpg" alt="exten1"><br>根据原型链的概念，SubType可以通过原型链去访问在SuperType中的方法getname，这就也差不多实现了继承的思想，最关键就是Subtype.prototype= new SuperType();这句话让Subtype.prototype为一个新建的SuperType对象，换个方式去理解，每次新建一个对象的时候，新的那个对象的<strong>proto</strong>属性都会指向构造这个对象的那个构造函数的原型，上述代码中，就是Subtype.prototype中的<strong>proto</strong>由原来指向objec.prototype变成了指向了SuperType.prototype，由此之后变可以通过原型链访问父类的属性。<br>还有一点需要注意的就是在这里name属性，在父类也有，在子类也有，子类会把父类的name给覆盖掉，对外呈现的就是在实例中的name，上述代码就是man。</p>
<p>##3.2稍微复杂点的继承##<br>先一个代码的部分</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>{
    <span class="keyword">this</span>.name = name;
    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];
}
SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
};
<span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">name ,age</span>)</span>{
    SuperType.call(<span class="keyword">this</span>,name);
    <span class="keyword">this</span>.age = age;
}
SubType.prototype = <span class="keyword">new</span> SuperType();
<span class="comment">//SubType.prototype.constructor = SubType;</span>
SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);
};
<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"niki"</span>,<span class="number">29</span>);
instance1.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//true</span>
instance1.hasOwnProperty(<span class="string">"colors"</span>);<span class="comment">//true</span>
instance1.hasOwnProperty(<span class="string">"age"</span>);<span class="comment">//true</span>
SubType.prototype.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//true</span>
SubType.prototype.hasOwnProperty(<span class="string">"sayAge"</span>);<span class="comment">//true</span>
SubType.prototype.hasOwnProperty(<span class="string">"colors"</span>);<span class="comment">//true</span>
</code></pre><p>然后也上一个图片<br><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140210_extend2.jpg" alt="extend2"><br>这个例子呢，其实继承的方式都是一样的，只不过在定义子类的方法中用到了call的方法，这里就是调用了SuperType的构造方法，还有一点需要注意的是SubType.prototype = new SuperType();会使得SubType.prototype的constructor属性指向父类的构造函数，如果需要让他指向SubType需要对他进行修改</p>
<p>//==貌似在博客上看到过其他的，下次看完了一起补上</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>写一些看到的继承的方法</p>]]>
    
    </summary>
    
      <category term="js" scheme="http://tankpt.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js整理二:this的一些理解]]></title>
    <link href="http://tankpt.github.io/2014/11/10/20140210_this/"/>
    <id>http://tankpt.github.io/2014/11/10/20140210_this/</id>
    <published>2014-11-09T16:02:41.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>关于this的一些理解</p>
<a id="more"></a>
<p>##2.1全局作用域下##</p>
<p>输入代码：console.log(this);//window<br>全局范围内的this将会指向全局对象，结果是window，这点毫无疑问</p>
<p>##2.2作为单纯的函数调用##</p>
<p>（1）先看一段代码：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fTest_this</span>(<span class="params"></span>)</span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>);
}
fTest_this();
</code></pre><p>结果为全局的window，这个是在浏览器的非严格模式下得出的</p>
<p>（2）下面再看一个严格模式下的测试，代码中再添加一句’usestrict’;</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fTest_this</span>(<span class="params"></span>)</span>{
<span class="pi">   'use strict'</span>;
    <span class="built_in">console</span>.log(<span class="keyword">this</span>);
}
fTest_this();<span class="comment">//undefined 但是貌似在谷歌浏览器在还是出现了window</span>
</code></pre><p>（3）为了再验证在非严格模式下指向的是window对象，再看下面的测试</p>
<pre><code><span class="function"><span class="keyword">function</span></span> fTest_this(<span class="keyword">name</span>){
       this.<span class="keyword">name</span> = <span class="keyword">name</span> ;
}
fTest_this(<span class="string">"hi"</span>);
console.<span class="built_in">log</span>(<span class="keyword">name</span>);//hi
<span class="keyword">name</span> = <span class="string">"bye"</span>;
console.<span class="built_in">log</span>(<span class="keyword">name</span>);//bye
</code></pre><p>最后输出的name的数值是bye，可以证明name属性在全局的window中</p>
<p>##2.3作为对象的方法调用##<br>先上一段代码（这个段代码是借用了参考博客中的那段代码）</p>
<pre><code>varname = <span class="string">"clever coder"</span>;
<span class="keyword">var</span> person = {
    name: <span class="string">"foocoder"</span>,
    hello: <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>)</span>{
            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+ <span class="string">" says "</span> + sth);
        }
}
person.hello(<span class="string">"hello world"</span>);
</code></pre><p>最后的输出为foocodersays hello world；对于这段代码的this，就是指向了该方法所在的对象，代码中就是peson对象；</p>
<p>##2.4作为构造函数##</p>
<p>更多的参考了博客（阮一峰老师），地址在文章的底部</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>{
　 <span class="keyword">this</span>.x = <span class="number">1</span>;
}
<span class="keyword">var</span> o = <span class="keyword">new</span> test();
alert(o.x); <span class="comment">// 1</span>
</code></pre><p>运行结果为1。为了表明这时this不是全局对象，我对代码做一些改变：</p>
<pre><code><span class="keyword">var</span> x = <span class="number">2</span>;
<span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>{
　　<span class="keyword">this</span>.x = <span class="number">1</span>;
}
<span class="keyword">var</span> o = <span class="keyword">new</span> test();
alert(x); <span class="comment">//2</span>
</code></pre><p>运行结果为2，表明全局变量x的值根本没变</p>
<p>##2.5内部函数##</p>
<p>（1）代码1</p>
<pre><code>window.<span class="property">name</span>= <span class="string">"window"</span>;
object = {
    <span class="property">name</span>:<span class="string">"object"</span>,
    <span class="command">run</span>:function() {
        console.<span class="command">log</span>(<span class="string">"test1:"</span>+this.<span class="property">name</span>);
    }
};
object.<span class="command">run</span>();
</code></pre><p>这个例子就是前面提到的2.3作为对象的方法调用，他里面的this指向的是其中的对象即object，所以上述的代码运行后在控制台中可以看到test1:object。</p>
<p>（2）然后继续对代码进行改动</p>
<pre><code><span class="built_in">window</span>.name = <span class="string">"window"</span>;
object = {
   name: <span class="string">"object"</span>,
   run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
            <span class="built_in">console</span>.log(<span class="string">"test1:"</span>+<span class="keyword">this</span>.name);
            <span class="keyword">var</span> inner =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            <span class="built_in">console</span>.log(<span class="string">"Myname is "</span> + <span class="keyword">this</span>.name);
        };
        inner();
   }
};
object.run();
</code></pre><p>输出的结果是My nameis window，即this指向的是window对象（顺便测试了一下，在严格模式下，依然会报错的）<br>关于这一点，在司徒正美的博客中，写着这样的解释“尽管它是定义在object内部，尽管它是定义run函数内部，但它弹出的既不是object也不是run，因为它既不是object的属性也不是run的属性。它松散在存在于run的作用域用，不能被前两者调用，就只有被window拯救。”<br>确实如此，inner()这个方法，既不能object去访问，也不能让run去访问，确实感觉很飘离，如果想让inner()内部的this也指向object的话，就可以把之前的this给保存在一个变量里，然后inner()再去调用；</p>
<pre><code><span class="built_in">window</span>.name = <span class="string">"window"</span>;
object = {
    name:<span class="string">"object"</span>,
    run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
           <span class="keyword">var</span> that =<span class="keyword">this</span>;
           <span class="built_in">console</span>.log(<span class="string">"test1:"</span>+<span class="keyword">this</span>.name);
           <span class="keyword">var</span> inner =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
           <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + that.name);
        };
        inner();
    }
};
object.run();
</code></pre><p>测试结果就是My name isobject，成功的保存了之前的指针。<br>还有其他的方法能实现上述的结果，就是call和apply的应用</p>
<p>最后附上以个司徒正美博客上的几句话，这是来自于他的整理<br>this 的值取决于 function 被调用的方式，一共有四种，<br>1．如果一个 function 是一个对象的属性，该 funtion 被调用的时候，this 的值是这个对象。如果 function 调用的表达式包含句点（.）或是 []，this 的值是句点（.）或是 [] 之前的对象。如myObj.func和myObj[“func”] 中，func被调用时的 this 是myObj。<br>2．如果一个 function 不是作为一个对象的属性，那么该 function 被调用的时候，this 的值是全局对象。当一个 function 中包含内部 function 的时候，如果不理解 this 的正确含义，很容易造成错误。这是由于内部 function 的 this 值与它外部的 function 的 this 值是不一样的。解决办法是将外部 function 的 this 值保存在一个变量中，在内部 function 中使用它来查找变量。<br>3．如果在一个 function 之前使用 new 的话，会创建一个新的对象，该 funtion 也会被调用，而 this 的值是新创建的那个对象。如function User(name) {this.name = name}; var user1 = newUser(“Alex”); 中，通过调用newUser(“Alex”) ，会创建一个新的对象，以user1 来引用，User 这个 function 也会被调用，会在user1 这个对象中设置名为name 的属性，其值是Alex 。<br>4．可以通过 function 的 apply 和call 方法来指定它被调用的时候的 this 的值。apply 和 call 的第一个参数都是要指定的 this 的值。由于它们存在，我们得以创建各种有用的函数。</p>
<p>##参考博文：##<br>1司徒正美 <a href="http://www.cnblogs.com/rubylouvre/archive/2009/11/13/1602122.html" target="_blank" rel="external">http://www.cnblogs.com/rubylouvre/archive/2009/11/13/1602122.html</a><br>2 阮一峰  <a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html</a><br>3.<a href="http://foocoder.com/blog/xiang-jie-javascriptzhong-de-this.html/" target="_blank" rel="external">http://foocoder.com/blog/xiang-jie-javascriptzhong-de-this.html/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于this的一些理解</p>]]>
    
    </summary>
    
      <category term="js" scheme="http://tankpt.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试整理]]></title>
    <link href="http://tankpt.github.io/2014/10/10/20141010_interview/"/>
    <id>http://tankpt.github.io/2014/10/10/20141010_interview/</id>
    <published>2014-10-10T14:33:23.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>整理了俩最近的面试，一直想总结的，怕越托忘记的越多<br><a id="more"></a></p>
<p>##面试一##</p>
<p>###一面###<br>时间有点久了，所以记得也有点不太清楚了，只是感觉运气还是挺好的。基本上的问题都还是回答出来的</p>
<ol>
<li>跨域的几种方法，回答了四五种，然后稍微解释了下用hash的方法以及存在的一些问题，还介绍了jsonp的原理</li>
<li><p>关于js继承的问题<br> 先是介绍了比较熟悉的原型链的方法，然后还有一个方法就是如下</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">inherite</span><span class="params">(obj)</span></span>{
    <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>{}
    f.prototype = obj;
    <span class="keyword">return</span> <span class="keyword">new</span> f();
}
</code></pre><p> 然后后面估计是面试官突然想到的，他说有一个函数p，内部定义了很多方法和对象，然后在构造的过程中比较消耗，问我怎么办，我当时理解的就是函数p以及他上面的原型链上都包含了很多的东西，就想不到怎么回答，后来问了。面试官的意思就是用上面的办法。只是我没听清除，这个只是函数本身比较复杂，对于原型上还是比较简单的<br>中间还问了一些原型的问题，我就拿着笔在纸上画了一些理解的东西给他看  </p>
</li>
<li>问了一个最简单的正则的问题，我回答平时只是用的时候会去查查，然后问了俩简单的。刚好会</li>
<li>css的盒子模型，正常跟不正常的两种</li>
<li>由于中间我提到了一些自己对于性能的问题的理解，他就让我说一些性能的优化，我说自己整理过一些，看过那个《网站建设指南》,里面一些基本的东西，自己平时还会注意比如变量的缓存，闭包，setTimeout的问题，还有就是图片最好一开始设置大小。防止后面突然加载进来之后的重绘的操作，然后还说了一些对于那些经常触发的事件，要控制好频率，比如onresize的事件，然后面试官让我写一些代码。然后==！很尴尬一下子卡住了</li>
<li>浏览器输入url后发生的事情，比较老套的问题，把我知道的都说给他听了，从dns开始查询。中间他问道有个建立链接的过程呢，我说是不是三次握手四次放手，然后补上细节的东西确实没有细学</li>
<li>然后我扯了一堆自己关于前端的想法还有感受</li>
<li>还问了几个老套的关于布局的问题。比如左边定宽右边自适应等等的问题</li>
<li>貌似还提到了bfc的用处还有就是bfc的原理</li>
<li>问了我平时是怎么学习前端的知识的。如何在后期稳定持续的学习上去，如何来提高自己的编码能力</li>
</ol>
<p>总结：感觉回答的挺好的，技术问题准确说来应该就一个没回答上来，然后还跟面试官扯了一些自己的体会跟想法，貌似把他忽悠住了</p>
<p>###二面###<br>这面比较神奇，因为遇到了一个很特别的面试官，他主要做的就是你来选点，他来问你你是怎么发现这个问题，怎么解决这个问题</p>
<ol>
<li>当时一看到我有一个整理的博客，然后就说直接看你写的东西好了，问你现在最想介绍这里面的哪个文章给我，我就说我印象中比较深的一点事情，然后了博文中整理的那个关于setTimeout的这个点的发现，有点印象很深刻</li>
<li>问到如何把一件产品做的更好，你会怎么做，我想了一下，首先说了一点前端需要做好一些技术上工作做好性能的优化，然后再提到应该参与到产品里的工作，提出自己的想法，然后就一点一点来问。我具体是怎么做的，有什么例子可以来说明你做了这些工作</li>
<li>最后我也向他问了下他们在node这方面是怎么在做的，他很nice，细心给我解答了一些他们的工作，一些里面用的技术细节，比如ps里面的东西可以用js来操作等等</li>
</ol>
<p>这面很奇怪更多是在跟面试官探讨一些东西，至于边上的hr。貌似就是在打酱油，最后随便问了家里情况。</p>
<p>总结：我还是相当喜欢这样的面试官，给人感觉很nice，毕竟技术的东西再怎么样总有你不会的盲点，最后顺利拿下了offer，最狗屎的一个</p>
<p>##面试二##</p>
<p>###笔试###<br>下班后跟小伙伴打车过去打了个酱油，题目还是很正规的那种，全是前端的题目，不像某公司的笔试，前端做哭了，感觉还不错，有关于闭包的东西，有关于移动端的东西就是手机端如果可以无限内容如何不让手机崩溃（这个我是随便猜的，不过最后看了结果，貌似猜对了），还有关于opcity，还有console等等的东西，题目感觉还是很基础的，最后貌似看到成绩==！50多分，但是面试官说貌似还不错的成绩</p>
<p>###面试一###<br>果然是做技术的公司就是不一样，深深被折服了</p>
<ol>
<li>问了有关position的问题，由于之前准备过了，所以按自己的理解解释了一遍</li>
<li>盒子模型</li>
<li>对笔试试卷中的一个有关闭包的问题进行的引申，主体是关于缓存的机制，我说用闭包保存参数还有结果；接着面试官又提到那如果现在这个函数应用到很频繁的情况下，还是要经常计算，效率不高吧；我说要不用一个数组来保存这些对象，然后她说那有可能连续很多都没重复不是也不高么，我突然接了一句。我说把数组定长，然后满了的时候把那些最少用的给剔除，他说怎么来实现呢，我回答用个conut来标记下，每次排序去掉最小的，他说每次么，效率不高诶，我后来想了想说就慢的时候，用一次的遍历来查找。貌似他感觉还好，但还不是他满意的答案。她说关于缓存的东西操作系统里应该会教过的==！我说真没印象了</li>
<li>然后又问了个给你个节点。你把所有的节点遍历出来，然后我就写了一个，，他看了下，说这样是可以，那如果我现在的节点很多，只要找到其中一个节点就可以停止了，你怎么做；我想了下问是类似递归么？他说可以，写完之后他说你这样貌似是深度优先做的，那写一个广度优先的，然后我写了一下。大致写了主要是思想，这个题目貌似答的还不错</li>
<li>问了点性能优化，然后我就按照自己的印象说了一些，我又说其实我之前有整理过的一些，他说，他知道++！在看，好紧张</li>
<li>问了事件的代理，我怎么来做，我给他解释了下我的思路，然后他想了一个应用的场景给我，我大概说给需要绑定的事件加个class再来判断，貌似没有让他很满意，然后我说下我如果遇到这样的场景会怎么来是实现，貌似还行</li>
<li></li>
</ol>
<p>总结：果然是风格不一样，偏重于编程能力还有算法，跟上面的偏重于产品什么的不一样，技术为主，感觉面的还是挺顺利的</p>
<p>###面试二###<br>面的不好，应该是挂了，面试官人超级赞，了解下我的情况，跟我聊了聊其他的东西，然后我也说了。缓解了下紧张，由于一开始犯2了，提了下用过他们公司的一个库，然后他问你知道那个是谁写的么，我说难道就是你们？他说对，还有昨天面试的那个一面面试官几个人一起的，我去，刚好撞上了，ps：第一次离开源库的作者这么近的距离</p>
<p>他说既然你提到这个库了，问了个问题，关于数学的。给跪了，他让我用程序的角度去实现，一直不开窍，最后他说了出来，真是跪了。这样风格的问题，真是想不到</p>
<ol>
<li>让我实现一个居中，先说父元素是定宽高的，我说直接position :aosulute，父元素position:relative，她说为什么要父元素设置呢，我回答了下，然后又继续问那父元素不是定宽高的怎么办，我又说了个方法，不过貌似回答的不是很好，而且有点忘记了==！ 之前还整理过的。唉。</li>
<li>然后又问了下单行字符过多的时候用省略号的时候怎么实现==！，我之前做的时候都是临时找，没有好好记，这回吃亏了吧</li>
<li>问了haslayout的问题，我说我看过但是没有很理解，意思就是让他别问了==！我说我看过一点bfc的东西</li>
<li>问我会那些hack，我写了俩，然后说还有呢，我说我基本不用hack，她说确实实际不怎么用</li>
<li>问我会正则么。我说基本不用，用的时候再去查找</li>
<li>给我一个字符串[1,2,2,5,’5’,’’]怎么去重，我说我遍历两次，第一次放到一个对象中，类似key-value的map的方式来存储；面试官说那这个5跟’5’你还能区分出来么？我说哎呀没看清，然后我又想了一会，说要不直接给每个KEY数值＋１，这样可以区分5跟’5’，面试官说可以么？＝＝我又不确定了，然后她说笔试题里的那个console的题目做的很差，我说恩；他提示到这个keymap的方式是对的，后来我又想了一会，说我有个馊主意，不知道可以否，说对于这些key值，我采用字符串拼接的方法typeof key +key的形式，他回答说可以</li>
<li>然后问我随即生成１-100之间的随机数，我说math.random里生成0-1之间的随机数，然后取整，但是我没记得具体的函数的名称＝＝，好尴尬，然后说让我排序下，我说对整个array进行一次sort，他说这样sort对么？我说对，她说不对，这样的按照字符的进行排序，我说那可以在sort传一个具体的排序函数，他让我写下，我说我只知道这个点，但是没试过，所以忘记了</li>
<li>还问了一个this的问题，我觉得好失败＝＝，这类的问题都挂了,估计给面试官的印象超级不好了把</li>
</ol>
<p>总结：面试官最后问了我下，你感觉面的怎么样，我说不好，他说也不好＝＝！恩，这就是挂的节奏了，他说我的笔试跟一面都挺不错的，但是这二面的水平，估计换成一面也要挂，说我基础还是略虚，特别是css方面</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>整理了俩最近的面试，一直想总结的，怕越托忘记的越多<br>]]>
    
    </summary>
    
      <category term="总结" scheme="http://tankpt.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从输入 URL 到页面加载完的过程中都发生了什么事情]]></title>
    <link href="http://tankpt.github.io/2014/10/09/20141009_browser/"/>
    <id>http://tankpt.github.io/2014/10/09/20141009_browser/</id>
    <published>2014-10-09T15:58:42.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>整理了关于输入url后的发生事件，未完待续，现在主要整理了dns还有解析html部分<br><a id="more"></a></p>
<p>##一、当在浏览器中输入一个网址的时候，首先会对输入的url进行判断，看他是否是一个标准的ip地址或者是域名；##<br>把URL分割成几个部分：协议、网络地址、资源路径。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。<br>例如：<a href="http://www.guokr.com/question/554991/" target="_blank" rel="external">http://www.guokr.com/question/554991/</a><br>协议部分：http<br>网络地址：www.guokr.com<br>资源路径：/question/554991/</p>
<p>(1)如果输入的是域名，那么就要发生dns的查询<br>首先会查询浏览器中的缓存，然后再查看系统的缓存，接着还会查看路由器的缓存，关于dns的查找，请看博文<a href="http://369369.blog.51cto.com/319630/812889/" target="_blank" rel="external">DNS原理及其解析过程精彩剖析</a><br>大致先查找本地host文件，再查找本地DNS解析器缓存，再查找首选DNS服务器</p>
<p>（迭代查询方式：查考自王道的网络书籍）<br>a.客户机向本地域名服务器发出DNS请求报文，<br>b.本地域名服务器受到请求后，查询本地缓存，若没该记录，以nds客户的身份向<strong>根域名服务器</strong>发出解析请求<br>c.根域名服务器受到请求后，判断是否属于.com域，将对应的<strong>顶级域名服务器</strong>的地址返回给本地域名服务器<br>d.本地域名服务器向顶级域名服务器dns.com发起解析请求报文<br>e.顶级域名服务器收到请求后，判断是否属于abc.com域，固将对应的<strong>授权域名服务器</strong>的地址返回给本地域名服务器<br>f.本地域名服务器向授权域名服务器发起解析请求报文<br>g.授权域名服务器受到请求后，将查询结果返回给本地域名服务<br>h.本地域名服务器将查询的结果保存到本地的缓存中，同时返回给客户机</p>
<p>##二、浏览器向web服务器发起一个http的请求##<br>在这里有建立tcp链接的过程</p>
<p>##三、服务器的永久重定向响应##<br>（从 <a href="http://example.com" target="_blank" rel="external">http://example.com</a> 到 <a href="http://www.example.com）" target="_blank" rel="external">http://www.example.com）</a></p>
<p>##四、浏览器跟踪重定向地址  浏览器向这个重定向的地址发起请求##</p>
<p>##五、服务器处理请求##</p>
<p>##六、服务器返回一个 HTTP 响应##</p>
<p>##七、浏览器显示 HTML##</p>
<p>###1 解析HTML以构建dom树###<br>解析html，将标签转化为内容树中的dom结点</p>
<p>###2 构建render树###<br>render树是由一些含有颜色和大小等属性的矩阵组成</p>
<p>(1) DOM树创建完成后DOMContentLoaded事件即触发，这时候可以用过script来操作DOM节点。在这里会涉及到css属性的重叠计算，就是计算出优先级的顺序；<br>(2)css样式应用到DOM节点上，呈现树的每一个节点即为与其相对应的DOM节点的CSS框，框的类型与DOM节点的display属性有关，block元素生成block框，inline元素生成inline框。每一个呈现树节点都有与之相对应的DOM节点，但DOM节点不一定有与之相对应的呈现树节点，比如display属性为none的DOM节点，而且呈现树节点在呈现树中的位置与他们在DOM树中的位置不一定相同，比如float与绝对定位元素。</p>
<p>###3 布局render树###<br>看了一个博文中的介绍提到了在这一步中，貌似布局这点第二步确实是把css附着到了节点上去，不过有些布局是需要通过浏览器的窗口来进行计算的，比如那种设定好width &amp;&amp; margin: 0 auto居中的元素，这一步做的应该都是把这些布局处理好，这一步是计算了具体的位置</p>
<p>注：当窗口在onresize的时候，会触发重绘</p>
<p>###4 绘制render树###<br>绘制应该就是把这些节点最后绘制在浏览中，包括了<br>(1) 背景颜色<br>(2) 背景图片<br>(3) 边框<br>(4) 子呈现树节点<br>(5) 轮廓</p>
<p>##8.浏览器发送请求获取嵌入在HTML中的资源（如图片、音频、视频、CSS、JS等等）##</p>
<p>##9.浏览器发送异步请求##</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>整理了关于输入url后的发生事件，未完待续，现在主要整理了dns还有解析html部分<br>]]>
    
    </summary>
    
      <category term="总结" scheme="http://tankpt.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[九月小结]]></title>
    <link href="http://tankpt.github.io/2014/09/21/20140921_sum/"/>
    <id>http://tankpt.github.io/2014/09/21/20140921_sum/</id>
    <published>2014-09-21T13:44:22.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>九月开学了，周围的学生也慢慢开始多了起来，暑假过去了，貌似想想以后都不会有暑假了，差不多是告别了学生的时代的感觉了，最近的身边的事还是发生了好多，改缕缕整理下了。<br><a id="more"></a></p>
<p>##关于工作##</p>
<p>###没好好用心###<br>平时天天还在公司里实习，这俩天工作有点多，其实想想也不多，貌似就是自己的能力不行，很多东西都没有好好去理解，心里还是有点想着在这段时间好好准备找工作的事情，然后那些业务的东西说真的没有好好去用心，恩，早点把工作的事情确定下来，好安心地投入进去</p>
<p>###细节把握不好，态度还需加强###<br>这俩天感觉有点乱了手脚了，bug老出，这一方面对自己的信心不好，另一方面让测试也不好，这样有一个恶性循环的过程，不过其中也有不错的收获的地方，就是又踩到了几个坑，恩，感觉工作久的那些走过的路，看过的东西多就多在了经验上，这点我还是决定挺开心的，不停实践，学到其中的坑是最好的收获</p>
<p>###将心比心，态度###<br>那天发生了一个事情，大概是这样的，老大问了大家十一请假不，然后一堆人一直都没回复，老大那天不开心，说了一句话“如果向期望别人对你热心点，那你怎么不先热情点呢？”。这句话还是挺受用的，与人于己都是好的</p>
<p>###主动！！###<br>那天遇到一个事情，就是向他们要一个链接，我向分给我工作的人Ａ询问，他说问Ｂ，问了Ｂ之后说问Ｃ，Ｃ又说问Ｄ，反正这个东西问了一圈都不知道，然后建了一个群，问了他们，结果我冷场了没人理我，挺尴尬的，关于这个问题，想了下，一方面确实是他们做事的不对，这样的踢皮球的行为确实不太好，对工作的效率很影响，不过另一方面，于己，在问了他们没反应后，我也没有主动过去问，处于了一个等待的过程中，<strong>很被动</strong>，这是病，要治。</p>
<p>##生活##</p>
<p>###朋友－－人生苦短，及时行乐，珍惜身边的朋友和亲人###<br>这周末大学的舍长结婚了，很遗憾没去，说个良心话，不是不想去，是下周有个面试，我也很看重那个面试，想好好准备，来回的时间有点短而折腾，所以那天拍了一个祝福视频发过去，说实话，好紧张，那个视频我自己大概拍了有十遍吧，还是很不自然，会紧张，傻傻的笑，好丢人，感觉在大学的时光里，我错过了很多，错过了很多跟他们一起玩的时光，我当时傻傻的在自习室里看逗比的书，发呆睡觉，那效率现在想想真是可笑。然后跟他们在一起，我会不知道怎么跟他们搭话，貌似看的东西跟他们的很不同<br><strong>但是我真的真的很享受跟他们在一起的时光，大学舍友，不曾忘记，剩下的我只能做到的是努力不错过他们每个人的婚礼。</strong></p>
<p>###身体###<br>最近有点忙，对身体有点亏待了，最近的腰有点不舒服，估计是腰肌劳损，哎，IT的就是这样。身体永远是第一，多多锻炼，周末去打球跑步了，来弥补下缺少的运动</p>
<p>##周围##</p>
<p>###关于阿里马云###<br>这周阿里上市了，股票飚的飞起，让阿里里面多少人一夜之间变成了千万过亿的土豪，很多人都羡慕不已，感叹自己为啥没有在阿里，或者感叹自己为啥不是那些初始的创始人，或者是早年进去阿里的人，我也这么感叹，但是后来看了一个视频突然就不感叹了，大概就是说了几个初始人之前是怎么走过来的，那时多么的不容易，突然就可以想通了，大家就看到了他们现在风光，没看到他们过去的艰难，他们能走过以前那个坎，现在所得的都是他们deserve</p>
<p>所有能熬过最艰难的时刻的人，最后成功了也是他们应得的，貌似有句话是这样说的，<strong>每一个人的选择都不是对的，但是他们能做的可以在一会努力去让他们的选择变为正确</strong>，所以没有什么好羡慕的，换成你，你也做不到那样的心态。</p>
<p>###关于多隆码神###<br>还有一个关于阿里的是最近听说的阿里的码神－多隆，码到了p11，成为了合伙人，从一开始初创的时候就在里面了，一直到现在为止，想想现在的人呢，还是很浮躁的，一个地方待了一段时间就会想着跳槽什么的，而他确是一口气在里面做了这么多年，你可以么？</p>
<p>the end </p>
<p>by tankpt </p>
<p>20140921 hangzhou xixi</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>九月开学了，周围的学生也慢慢开始多了起来，暑假过去了，貌似想想以后都不会有暑假了，差不多是告别了学生的时代的感觉了，最近的身边的事还是发生了好多，改缕缕整理下了。<br>]]>
    
    </summary>
    
      <category term="感悟" scheme="http://tankpt.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一些关于居中的整理]]></title>
    <link href="http://tankpt.github.io/2014/09/16/20140916_middle/"/>
    <id>http://tankpt.github.io/2014/09/16/20140916_middle/</id>
    <published>2014-09-16T14:42:50.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>关于这类居中的问题，貌似各种考的会很多，然后生产实践中也确实会遇到很多，网上随便一搜也能找到很多狠多的例子，这里就简单整理一下自己到现在用过的一些方法，都算是比较简单的然后兼容问题较好的，能大部分解决遇到的问题，但是对于一些极端变态的情况，这里的貌似有些力不从心。<br><a id="more"></a></p>
<p>##一、水平居中##</p>
<p>###1. 文字居中###<br>对于一些文字向让他在一个块内居中，最简单的方法就是可以对父元素进行设置</p>
<pre><code>.center{<span class="type">text</span>-align:center;}
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"center"</span>&gt;
    一些居中的内容
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>###2. 定宽的块居中(父元素宽度未知)###<br>适用于一个有着定宽的块，让他居中，这个情况还是很常见的，比如在切图的时候，要中间设置一个width:960px的块，让他始终都居中，无论浏览器的宽度被拉到多大</p>
<pre><code>.center{margin:<span class="number">0</span> auto;<span class="variable">width</span>:<span class="number">960</span>px;<span class="built_in">background</span>-<span class="built_in">color</span>:<span class="built_in">red</span>;}
&lt;div class=<span class="string">"center"</span>&gt;
    始终居中的块
&lt;/div&gt;
</code></pre><p>###3. 定宽的块(父元素的宽度已知)###<br>对于这种情况可以简单粗暴的方法来解决，大致的思路就是既然都知道了让这个块居中时，它的左偏移的距离了，那么用定位（或者内边距）来解决，</p>
<pre><code>.demo3{width: <span class="number">400</span>px;}
.demo3 .child{width: <span class="number">100</span>px;margin-left: <span class="number">150</span>px;}
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"demo3 red"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"child blue"</span>&gt;I'm child Block&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>或者是下面的方法</p>
<pre><code>.child1{position: relative;left: <span class="number">50</span>%;margin-left: -<span class="number">50</span>px;width: <span class="number">100</span>px;}
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"demo3 red"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"child1 blue"</span>&gt;I'm child Block&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>不过这样应用的场景不会很多，毕竟也太如意了</p>
<p>###4. table的方法###</p>
<p>关于table的方法，大家在试用表格的时候也看到了，在表格里面的元素可以很简单的居中，所以在display的属性里面也有设置父元素display:table，然后再设置子元素为display:table-cell，不过这种方式考虑到这个兼容性的问题，自己平时没用到，例子就省去了</p>
<p>下面贴上几个水平的例子效果<br><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140916_middle1.png" alt="水平居中"></p>
<p>##二、垂直居中##</p>
<p>###1. line-height只有一行文字###<br>对于有些块，需求需要让他垂直居中，然后比较特殊的是他里面的内容只会在一行里出现，最常见的就是要放置一个按钮的时候了，要让里面的内容简单的居中，针对这类问题最简单的就是设置line-height==父元素的高度</p>
<pre><code>.demo1{<span class="variable">width</span>: <span class="number">150</span>px;font-<span class="built_in">size</span>: <span class="number">20</span>px;<span class="variable">height</span>: <span class="number">50</span>px;<span class="built_in">line</span>-<span class="variable">height</span>: <span class="number">50</span>px;<span class="built_in">text</span>-align: center;}
&lt;div class=<span class="string">"demo1 red"</span>&gt;
    button
&lt;/div&gt;
</code></pre><p>这里的原理涉及到行框的形成</p>
<p>###2. vertain-align＋line-height###<br>这个方法是直接摘录自博客了，里面有两点需要注意</p>
<ol>
<li>父元素font-size需要设置为0，这个跟vertain-align:middle的定义有关，可以具体看参考博文１;</li>
<li>还有一点比较重要的是要对子元素的line-height进行重置，因为line-height会有继承的效果，所以如果不重置，大家可以看看效果</li>
</ol>
<pre><code>.outer { <span class="built_in">line</span>-<span class="variable">height</span>: <span class="number">100</span>px; <span class="variable">height</span>: <span class="number">100</span>px; font-<span class="built_in">size</span>: <span class="number">0</span>; }
.inner { display:inline-block; vertical-align:middle; font-<span class="built_in">size</span>: <span class="number">16</span>px;<span class="variable">height</span>: <span class="number">50</span>px;<span class="variable">width</span>: <span class="number">100</span>%;<span class="built_in">line</span>-<span class="variable">height</span>: <span class="built_in">normal</span>;  }
&lt;div class=<span class="string">"outer red"</span>&gt;
    &lt;div class=<span class="string">"inner blue"</span>&gt;child&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>###3. 类似水平居中的3(父元素的高度已知)###<br>同上面的３一样只过不过这回修改的top　还有height的属性而已</p>
<p>###4. 绝对定位外边距为auto可以得到垂直居中###<br>这个方法是在《css权威指南》的时候看到的，大体的思路就是让一个绝对定位的元素eft: 0; top: 0; right: 0; bottom: 0;</p>
<pre><code>.demo3{<span class="string">position:</span> relative;<span class="string">height:</span> <span class="number">200</span>px;<span class="string">width:</span> <span class="number">400</span>px;}
.demo3 .child{<span class="string">position:</span> absolute;<span class="string">margin:</span> auto <span class="number">0</span>;<span class="string">width:</span> <span class="number">200</span>px;<span class="string">height:</span> <span class="number">100</span>px;absolute; <span class="string">left:</span> <span class="number">0</span>; <span class="string">top:</span> <span class="number">0</span>; <span class="string">right:</span> <span class="number">0</span>; <span class="string">bottom:</span> <span class="number">0</span>;}
&lt;div <span class="class"><span class="keyword">class</span>="<span class="title">demo3</span> <span class="title">red</span>"&gt;
    &lt;<span class="title">div</span> <span class="title">class</span>="<span class="title">child</span> <span class="title">blue</span>"&gt;<span class="title">test</span>&lt;/<span class="title">div</span>&gt;
&lt;/<span class="title">div</span>&gt;</span>
</code></pre><p><img src="http://7vzsgl.com1.z0.glb.clouddn.com/blog20140916_middle2.png" alt="水平居中"></p>
<p>其实还有很多的方法，比如css３上面就有很多，不过自己平时也没怎么使用，所以也就不加了<br>附上<a href="https://gist.github.com/7f624c4d82ccd99c5ccf.git" target="_blank" rel="external">代码gist</a></p>
<p>参考博文<br><a href="http://blog.segmentfault.com/humphry/1190000000381042" target="_blank" rel="external">整理：子容器垂直居中于父容器的方案</a>　整理的超级不错<br><a href="http://www.qianduan.net/css-to-achieve-the-vertical-center-of-the-five-kinds-of-methods.html" target="_blank" rel="external">CSS实现垂直居中的5种方法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于这类居中的问题，貌似各种考的会很多，然后生产实践中也确实会遇到很多，网上随便一搜也能找到很多狠多的例子，这里就简单整理一下自己到现在用过的一些方法，都算是比较简单的然后兼容问题较好的，能大部分解决遇到的问题，但是对于一些极端变态的情况，这里的貌似有些力不从心。<br>]]>
    
    </summary>
    
      <category term="css" scheme="http://tankpt.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于前端性能的一点整理（未完待续）]]></title>
    <link href="http://tankpt.github.io/2014/09/14/20140914_performance/"/>
    <id>http://tankpt.github.io/2014/09/14/20140914_performance/</id>
    <published>2014-09-14T02:49:25.000Z</published>
    <updated>2015-10-17T13:29:10.868Z</updated>
    <content type="html"><![CDATA[<p>整理一些自己在平时看到过的有关性能优化的东西（未完待续)</p>
<a id="more"></a>
<p>前段时间看到很多人在提到有关算法的东西，后来想了想感觉步入前端这个行业，算法这个东西貌似相对于后端来说更为遥远了，个人觉得算法提供了两种思路：一种是解决问题的办法，还有一种是提高效率的途径。解决问题的办法诸如那些图的算法等等，提高效率的话有贪心，排序等等一些，这些对于后端确实应该挺重要的，或者是数据库的查询；不过对于前端，所关注的也许是其他的东西了，因为在其他上面所能提高的东西远远大于这些。[仅是个人的一点点见解，最后有一个关于《高性能网站建设指南》的阅读笔记，所以在那里出现的对象，我就不累赘了]</p>
<p>##HTML##</p>
<ol>
<li>关于 \&lt;\img src=”” >这样图片的资源链接为空的情况下，之前在几篇文章里看到会产生一个比较奇怪的现象就是会对页面发起两次请求，建议用个默认的图片先；（这里补充一点，就是当这个src属性为空的时候，js读这个属性，读到的不是””，而是此时的location.href）</li>
<li>关于图片一般在切图的时候都会有大小的限制，所以可以给他的外边框在写的时候都加上高度跟宽度，这样避免图片一开始没有到后面有，内容上发生一个抖动，而且对于浏览器来说，这样的重构渲染树也是比较损耗的</li>
</ol>
<p>##css##</p>
<ol>
<li><strong>css选择器的效率</strong> ！！ div.nav &gt; ul li a[title]<br>上面的实例来说，浏览器首先会尝试在你的HTML标签中寻找“a[title]”元素，接着在匹配“li和ul”，最后在去匹配“div.nav”。这就是前成所主的“选择器从右到左的原则”,所以根据这样的原则，其实不可以在为了定义一个具体class的样式，通过很多层的套用</li>
</ol>
<h2 id="##javascript##">##javascript##</h2><ol>
<li><p>变量的缓存（分几种应用场景）<br>　(1) 作用域链和原型链上的优化：原型链的查找需要沿着原型链以此往上进行遍历，所以将需要的直接保存在一个变量中<br>　(2) 多层对象上的缓存，比如</p>
<pre><code><span class="title">var</span> _obj = {
    <span class="title">A</span> :{
        <span class="title">A1</span> : {
            <span class="title">name</span> : <span class="string">"ok"</span>
        }
    }
};
</code></pre><p> 要经常使用_obj.A.A1.name的话，最好也将他缓存起来，感觉有点类似空间来换时间的感觉，少查找几次<br>　(3) for循环数组缓存数组长度：一般的情况下数组的长度都是固定的所以每次都去读同一个数组的长度这里的损耗<br>　(4) 对一些变量的undefine判断可以试用void　0;之前看到一个解释是如下：void　0效果等同undefined，只是undefined是一个全局变量，需要变量名查找，void 0不但字数少，而且理论上避免了对undefined变量名的查找，效率高，理论上！！！（这点也是当时看underscore的时候发现的）<br>　(5)缓存DOM对象：这个还是很明显，每次查找一个id或者一个class，都是比较消耗的，id还好，因为在语义上就指明了是唯一出现的，我也没具体了解过这个查找方法具体是怎么实现的，不过感觉应该是只要找到一个id就可以停止搜索了，而对于class应该都是要遍历一遍文档的，所以做好这些对象的缓存估计可以提升不少的效果<br>　<br>　总结：其实还有一点关于这个缓存的解释就是一般的情况下，最后的代码都会需要进行压缩，所以如果一个变量是_obj.A.A1.name，那么进行压缩后最少也应该是a.b.c.d这样的形式，不过如果你进行了缓存，那么最后的情况会是a，这里可能会对压缩完毕的代码大小有一定的影响（来自于前几天看的一个jquery解释视频里提到的）</p>
</li>
<li><p>控制好一些经常触发的事件的频率：比如有时候需要的时候会对浏览的onresize事件进行监听，如果不控制好频率，只是一味的在当外界resize的时候就触发这个动作，那么对于浏览的监听事件也有点过于损耗了，想象一些，当你调整浏览器的时候，他是每一个时间的间隔其实都触发了这个事件，特别是当那个监听事件里写了很多复杂的而且消耗资源的事件，这样貌似在低版本的一些浏览器都会卡住，解决的方法就是</p>
<pre><code><span class="keyword">var</span> resizeEvent = <span class="literal">null</span>;
<span class="keyword">if</span> (resizeEvent) {
    clearTimeout(resizeEvent)
}
resizeEvent = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="comment">/*event*/</span>
}, <span class="number">400</span>);
</code></pre></li>
</ol>
<p>3.　做好回收的工作：</p>
<p>　 (1) 注意一些事件的回收，比如在用模块的方式来写代码的时候，一个模块调用进来注册了一些事件，然后当这个模块被切换走的时候，要注意把这些事件都进行清空处理，现在正常的js的垃圾回收应该都是引用计数的，所以长期这样切过来切过去，会有很多无效的浪费，更重要的是同一个模块被切回来切出去的动作经常进行的话，会在一个动作上触发同一个事件很多次，比如发一个请求发了很多次，这里也是有一些损耗的;<br>　 (2) 注意那些闭包的回收;<br>　 (3) 注意类似setTimeout这类的回收;</p>
<ol>
<li>后续继续更新</li>
</ol>
<p>##其他##</p>
<hr>
<p>附上之前看过的《高性能网站建设》的一点笔记</p>
<p>###绪论###</p>
<ol>
<li>黄金法则：只有10%~20%的最终用户相应时间花在了下载HTML文档上，其他都是花在了下载页面中的所有组件上</li>
<li>压缩：有时候发送一个请求，可以带上一个Accept-Encoding来表明支持压缩；</li>
<li>条件get请求：如果浏览器中保存了一个组建的副本，可以发送一个请求中附带着modified的信息，然后服务器可以对比下，如果缓存有效地话可以用一个更小且更快的响应返回给浏览器(304 not modify)</li>
<li>Expires：虽然方法３可以让页面加载更快，但是还是需要客户端和服务器之间一次的来回；而Expires可以消除这个需求</li>
<li>Keep-alive：在http的早期的实现中，http请求都是要打开一个socket的请求；有时候页面中的很多资源都是同时指向同一个服务器，持久链接就是解决了这个问题  [需要研究下持久连接的]</li>
</ol>
<p>###规则１－减少http请求###</p>
<ol>
<li>用图片中的map的方法，这样一块区域只需要一次图片的请求</li>
<li>css Sprites 切图定位</li>
<li>内联图片（比如图片的信息可以试用base64的编码）</li>
<li>合并脚本和样式表</li>
</ol>
<p>###规则２－使用内容发布网络Content Delivery Network (CDN)###<br>CND：一组分布在多个不同地理位置的web服务器，用于更加有效向用户发布内容；向特定用户发布内容的服务器的选择基于对网络可用度的测量（例如选择网络阶跳跃数最小的服务器，或者是具有最短响应时间的服务器）</p>
<p>CND：用于发布静态内容，如图片、脚本、样式表和Flash，不过有一个缺点是响应事件可能会受到其他网站的影响，CND服务提供商在其所有客户之间共享web服务器组件，还有一个缺点就是不能直接控制组件服务器带来的麻烦（比如修改http响应头）</p>
<p>###规则３－添加Expires头###</p>
<ol>
<li>Expires头<br> web服务器试用这个表示来告诉客户端可以使用当前的副本直到某个时间<br>缺点：使用了一个特定的时间要求服务器和客户端的时钟严格同步，而且过期时间需要经常检查</li>
<li>Max-Age 和 mod_expires（另一种方式）<br> 缺点是不支持HTTP1.1</li>
<li><p>空缓存VS完整缓存</p>
</li>
<li><p>缓存的对象不仅仅只是图片还可以是脚本样式表还有flash组件</p>
</li>
<li>修订文件名<br> 对于一些还没过过期时间，但是服务器已经更新内容的情况，浏览器还是不会进行更新的，这个时候可以采用修订文件名，比如加一个版本号</li>
</ol>
<p>###规则４－压缩组件###</p>
<p>客户端可以通过http请求中的Accept-Encoding标示对压缩的支持</p>
<ol>
<li>压缩的内容<br> 值得压缩的应该是包括XML和JSON在内的任何文本响应，对于图片和PDF不应该压缩，压缩会给服务端加一些压力，可能会浪费CPU资源；而且客户端需要对这些压缩的资源进行解压</li>
<li>代理缓存<br> 之前介绍的都是在浏览器于服务器直接通信的情况下；有时候浏览器会通过代理向服务器发送请求，然后代理会缓存请求的资源，代理需要处理好，一些客户端请求不要压缩一些客户端需要压缩的情况 可以试用字段vary</li>
<li>边缘情况<br> 有些浏览器不支持压缩的格式需要进行处理</li>
</ol>
<p>###规则５－将样式表放在顶部###</p>
<p>注意@import会产生一些问题（导致组建下载无序性；出现白屏，无样式内容的闪烁），所以最好试用link，</p>
<p>###规则６－将脚本放在末尾###</p>
<ol>
<li>http1.1中规范建议浏览器从每个主机名并行地下载两个资源，具体还是需要看浏览器的；不过不是越多的并行下载越好，过多的并行下载反而会降低性能</li>
<li>脚本阻塞下载[脚本是不能进行并行下载的，原因:脚本里可能有document.write之类的方法；脚本中很有可能需要按照一定的顺序进行即有依赖关系]</li>
</ol>
<p>###规则７－避免css表达式###</p>
<p>###规则８－使用外部js和css###</p>
<ol>
<li>纯粹而言，内联更快；但是JS和CSS是有机会可以被缓存起来的</li>
<li>需要考虑的基准：页面查看、空缓存VS完整缓存、组件重用</li>
<li>加载后下载：意思就是某个页面加载完毕之后再加载一些资源，而这些资源是为了缓存起来，给用户访问其他页面所需要的资源提前先缓存下</li>
<li>动态内联：意思就是根据一定的条件在服务端进行处理，对某些情况返回的页面是内联的页面，而有些情况下返回的是外连的页面</li>
</ol>
<p>###规则９－减少DNS查找###</p>
<p>这里还是需要衡量一下，因为前面提到了如果用了不同的服务器，那么一些资源可以进行并行的下载<br>通过使用Keep-Alive和较少的域名来减少DNS的查找</p>
<p>###规则10－精简javascript###</p>
<ol>
<li>混淆<br> 缺点：混淆过程可能引入错误；不好维护；不好测试</li>
<li>精简css比如类的合并，还有就是字符串进行缩写</li>
</ol>
<p>###规则11－避免重定向###</p>
<ol>
<li>一些重定向的类型：<br> 300 301 302 303 304 305 306 307<br> 其中301 302是用的最多的</li>
<li>其他细节<br> (1)在URL的结尾必须处出现／但是没有出现<br> (2)主机名缺少结尾/不会产生重定向<br> (3)连接网站、跟踪内部流量、跟踪出战流量、美化URL</li>
</ol>
<p>###规则12－移除重复的脚本###<br>会产生不必要的HTTP请求、执行js所浪费的时间</p>
<p>###规则13－配置Etag###</p>
<p>###规则14－使Ajax可缓存###</p>
<p>确保Ajax请求遵守性能指导，尤其应具有长久的Expires头部</p>
<p>by tankpt<br>2014.09.14</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>整理一些自己在平时看到过的有关性能优化的东西（未完待续)</p>]]>
    
    </summary>
    
      <category term="总结" scheme="http://tankpt.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
